<?xml version="1.0" ?>

<!DOCTYPE article SYSTEM "/usr/share/sgml/docbook/dtd/xml/4.5/docbookx.dtd">


<article status="draft" class="specification"> <title>Enhanced Discrete Events System framework (graph based). Design.</title>

    <articleinfo>
	<author><personname><firstname>Yuri</firstname><surname>Borisov</surname></personname>
	    <email>yuri.borisov.v@gmail.com</email></author> 

	<releaseinfo>Ver.0.01 at 03-Mar-2013</releaseinfo>

	<abstract>
	    <simpara>This document collects use-cases and software desing for Discrete Events System framework ver 2.</simpara>
	</abstract>

	<revhistory>
	    <revision> <revnumber>0.01</revnumber> <date>03-Mar-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Initial version</revremark> </revision>
	    <revision> <revnumber>0.02</revnumber> <date>21-Mar-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_conn_01"/></revremark> </revision>
	    <revision> <revnumber>0.03</revnumber> <date>06-Jul-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_ifcache"/></revremark> </revision>
	    <revision> <revnumber>0.04</revnumber> <date>14-Jul-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_base_02"/>. Updated <xref linkend="ds_ifcache_01"/></revremark> </revision>
	</revhistory>

    </articleinfo>

    <bibliolist>
	<title>References</title>
    </bibliolist>


    <glossary> <title>Glossary</title> 

	<glossentry id="gls_cp"><glossterm>CP</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>Connection Point</para> <para>
		    Element that is used as endpoint of connections between systems.  
		    </para></glossdef> </glossentry>

    </glossary>
    
    <sect1 id="ds_base"> <title>Base</title>
	<sect2 id="ds_base_01"><title>DS_BASE_01 Getting iface</title>
	    <sect3><title>Description</title>
		<simpara>
		    In DES iface can be considered as atomic behavior. Getting iface is contained in base CPP APIs - GetObj. 
		    Many of components customize  that APIs. For instance the connection point is customizing the APIs to redirect
		    the request to real provider of the iface, for connpoint is a proxy only.
		</simpara>
		<simpara>Thus the redirection chain can be complex, so getting iface APIs should avoid looping. There could be several 
		    design approach:</simpara>
		<itemizedlist>
		    <listitem>Using agents extention mechanism. Redirect request to higher level of native hierarchy if the current level
		       cannot handle the request.	
		    </listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_base_02"><title>DS_BASE_02 Native behaviour. Agents.</title>
	    <sect3><title>Description</title>
		<simpara>The current implementation of elements extention for adding native bahavior is not consistent.</simpara>
	    </sect3>
	    <sect3><title>Discussion</title>
		<sect4><title>What are agents: component or internals of element.</title>
		    <simpara>Currently agents are implemented as components of element. Making them specific is done via collecting them in one
			specific part of element - "Agents" container. This solution foolows general approach of "cooperation" when the required complexity
			of system is secured via cooperation between elements. So extending of native behavior of element is done via cooperation of base
			element to embedded agents. But consequences of that is that agents are "regular" elements.</simpara>
		</sect4>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_conn"><title>Connections</title>
	<sect2 id="ds_conn_01"><title>DS_CONN_01 Connection points</title>
	    <sect3><title>Description</title>
		<simpara>
		    Connection points (CP) are endpoints of connections. System contains CPs and exhibits system's interfaces via CPs.
		</simpara>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_conn_03"><title>DS_CONN_03 CP interface</title>
	    <sect3><title>Description</title>
		<simpara>It is required for CPs to provide specific iface. One of the case where it can be used is
		    finding out "pair" of connection especially if sockets with deep hier are connected (also via extenders).
		    The problem when complex sockets is that some component within this hier is "virtually" connected
		to some pair, but there is no simple mechanism to find the "pair".</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_conn_02"><title>DS_CONN_02 Sockets</title>
	    <sect3><title>Description</title>
		<simpara>
		    Socket is the complex CP - element that collects some CPs, EPs, and sockets. 
		    Like simple CP Socket is located in system or capsula of Incaps.
		    When connecting two sockets the observed hier element, normally Incapsulated system (Incaps)
		</simpara>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_ifcache"><title>Interfaces cache</title>
	<sect2 id="ds_ifcache_01"><title>DS_IFCACHE_01 Key scheme for cache</title>
	    <sect3><title>Description</title>
		<simpara>Current solution [6d15a3f2] uses key [Name, Requestor, Provider] where Requestor and Provider are pointers. This makes some limitation in
		    requests to cache. For instance the cases cannot be distinquished when agent is requested for iface from one and another conn points, 
		    because for agents cache the direct Requestor is agents host but not conn points. Refer to unit test ut_func_seq4.xml, agent of "Conv"
		    needs to distinquish requests from CP "Out" and CP "Out_WFarg" but it's not possible. Is is the indication of the current mechanism not
		    consistent? Do we need improvement of cache mechanism?</simpara>
	    </sect3>
	    <sect3 id="ds_ifcache_01_disc"><title>Discussion</title>
		<itemizedlist>
		    <listitem>A: No it is not. We simply need to adjust Conv to the scheme. The current implementation of Conv is not correct. </listitem>
		    <listitem>14Jul2013 Yes, the scheme is incorrect. It doesn't provide correct iface instance in case of request thru socket pin, 
			especially if pins are for the same iface, ref Ut_conn::test_Sock():58 [7618b16c5199]. The first step ut requested iface 
			MDIntGet from Cp1, socket "Out" updates cache with MDIntGet iface from Cp1. The second step ut requests iface
			from Cp2, but Out returns the previously cached iface because it cannot distinquish requestor.</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Solution: refuse ifaces caching approach at all, but use pseudo connections for all connpoints.</title>
		<simpara>Do we need caching really? Architecturally, caching is just establishing direct pseudo connections, that simplify an access
		    to iface instances. It is not confirmed that the overhead will be resonable for the case when we have the pseudo connections for 
		    totally all elements of system. Isn't better to use some intermediate scheme, where only some elements have it, for instance
		    only connpoints as they conduct most of communications.</simpara>
		<simpara>To implement this some specific iface for CP needs to be introduced: to get cp pair, to get iface from this pair host,
		    probably something else.</simpara>
		<simpara>Pros of this solution is that it is a bit simpler for understanding. Cons for the solution is that two steps needs for 
		getting iface: step_1 is to get cp pair, step_2 is to get iface from this pair host.</simpara>
	    </sect3>
	    <sect3><title>Solution: extending of scheme by using full path from requestor.</title>
		<simpara></simpara> 
	    </sect3>
	    <sect3><title>Solution: to avoid having cache in agent (doesn't solve the problem actually)</title>
		<simpara>Original scheme seems resonable, the requests should be distinquish with even only level of requestor specified. 
		    The problem we faced is because of having agent as extra layer. Look at example we refeered in <xref linkend="ds_ifcache_01_disc"/>
		    Ut_conn::test_Sock():58. Ideally the "path" should be: Cp2 - L1 - Out - Cp2 - Data_2. But in reality we have:
		    Cp2 - L1 - Sock (agent) - Out - Sock (agent) .... So the link L1 - Sock (agent) eliminates the request distinquishness from Cp2. The 
		    question is "Can we avoid this cashe in agents?". This solution is also related to solution for agents, ref <xref linkend="ds_base_02"/></simpara>
		<simpara>No, it cannot solve the problem. Theer still will be sutuation where the one level requestor is not enough to correctly resolve
		    iface in cache. </simpara>
	    </sect3>
	    <sect3><title>Solution: using specific CP iface to get pair of socket's pin</title>
		<simpara>The idea is to fit CP with specific iface that provides getting "virtual" pair in case if CP is socket's pin.
		    Socket's pin requested for this iface, gets pair and redirect iface request to it. </simpara>
	    </sect3>
	</sect2>
    </sect1>

</article>
