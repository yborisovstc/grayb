<?xml version="1.0" ?>

<!DOCTYPE article SYSTEM "/usr/share/sgml/docbook/dtd/xml/4.5/docbookx.dtd">


<article status="draft" class="specification"> <title>Enhanced Discrete Events System framework (graph based). Design.</title>

    <articleinfo>
	<author><personname><firstname>Yuri</firstname><surname>Borisov</surname></personname>
	    <email>yuri.borisov.v@gmail.com</email></author> 

	<releaseinfo>Ver.0.05 at 18-Jan-2014</releaseinfo>

	<abstract>
	    <simpara>This document collects use-cases and software desing for Discrete Events System framework ver 2.</simpara>
	</abstract>

	<revhistory>
	    <revision> <revnumber>0.01</revnumber> <date>03-Mar-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Initial version</revremark> </revision>
	    <revision> <revnumber>0.02</revnumber> <date>21-Mar-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_conn_01"/></revremark> </revision>
	    <revision> <revnumber>0.03</revnumber> <date>06-Jul-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_ifcache"/></revremark> </revision>
	    <revision> <revnumber>0.04</revnumber> <date>14-Jul-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_base_02"/>. Updated <xref linkend="ds_ifcache_01"/></revremark> </revision>
	    <revision> <revnumber>0.05</revnumber> <date>18-Jan-2014</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_base_03"/></revremark> </revision>
	    <revision> <revnumber>0.06</revnumber> <date>10-Feb-2014</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_mut"/></revremark> </revision>
	</revhistory>

    </articleinfo>

    <bibliolist>
	<title>References</title>
    </bibliolist>


    <glossary> <title>Glossary</title> 

	<glossentry id="gls_cp"><glossterm>CP</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>Connection Point</para> <para>
		    Element that is used as endpoint of connections between systems.  
		    </para></glossdef> </glossentry>

    </glossary>
    
    <sect1 id="ds_base"> <title>Base</title>
	<sect2 id="ds_base_01"><title>DS_BASE_01 Getting iface</title>
	    <sect3><title>Description</title>
		<simpara>
		    In DES iface can be considered as atomic behavior. Getting iface is contained in base CPP APIs - GetObj. 
		    Many of components customize  that APIs. For instance the connection point is customizing the APIs to redirect
		    the request to real provider of the iface, for connpoint is a proxy only.
		</simpara>
		<simpara>Thus the redirection chain can be complex, so getting iface APIs should avoid looping. There could be several 
		    design approach:</simpara>
		<itemizedlist>
		    <listitem>Using agents extention mechanism. Redirect request to higher level of native hierarchy if the current level
		       cannot handle the request.	
		    </listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_base_02"><title>DS_BASE_02 Native behaviour. Agents.</title>
	    <sect3><title>Description</title>
		<simpara>The current implementation of elements extention for adding native bahavior is not consistent.</simpara>
	    </sect3>
	    <sect3><title>Discussion</title>
		<sect4><title>What are agents: component or internals of element.</title>
		    <simpara>Currently agents are implemented as components of element. Making them specific is done via collecting them in one
			specific part of element - "Agents" container. This solution foolows general approach of "cooperation" when the required complexity
			of system is secured via cooperation between elements. So extending of native behavior of element is done via cooperation of base
			element to embedded agents. But consequences of that is that agents are "regular" elements.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_base_03"><title>DS_BASE_03 Syntax of URI</title>
	    <simpara>The unified URI can be considered as node(s) determination request. The general form is as:</simpara>
	    <programlisting>
		uri = {"(" id_node_base_rel rel_sep ")"} node_name
	    </programlisting>
	    <simpara>Example is as:</simpara>
	    <programlisting>
		(hier_predecessor/)(inheritance_predecessor:)(vertex_pair~) name

		where:
		hier_predecessor - owner in base hierarchy
		/ - base hier separator - sign of base hier relation
		inheritance_predecessor - parent
		: - inheritance separator - sign of inheritance relation
		vertex_pair
		~ - vertex relation separator - sign of vertexes relations
	    </programlisting>
	    <simpara>So the uri is hierarchical (tree form) of relation specifying. This spec should be full enough to specify one node or set of nodes.</simpara> 
	    <simpara>The parentheseses are required to separate the branch of URI hierarchical tree. Having several layers in this tree causes the nested parentheseses that makes 
		this syntax rather incovenient even complete.
		The syntax of URI can be simplified in order to avoid parentheseses
		(they are very inconvenience indeed) by applying some restrictions to relations. For instance the currently used form of URI - GUri can be considered as
		the variant of generic form if we apply the restriction "chain of relation of some type can include only relation of this type". In this case the branches can 
		be resolved simply by relation type separator:</simpara>
	    <programlisting>
		n1/n2/n3/p3:p2:p1:node
	    </programlisting>
	    <simpara>No need to isolate the branch because the end of inheritance relation branch (p3:p2:p1) can be simply determined by changing of relation separator from ":" to "/"</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_conn"><title>Connections</title>
	<sect2 id="ds_conn_01"><title>DS_CONN_01 Connection points</title>
	    <sect3><title>Description</title>
		<simpara>
		    Connection points (CP) are endpoints of connections. System contains CPs and exhibits system's interfaces via CPs.
		</simpara>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_conn_03"><title>DS_CONN_03 CP interface</title>
	    <sect3><title>Description</title>
		<simpara>It is required for CPs to provide specific iface. One of the case where it can be used is
		    finding out "pair" of connection especially if sockets with deep hier are connected (also via extenders).
		    The problem when complex sockets is that some component within this hier is "virtually" connected
		    to some pair, but there is no simple mechanism to find the "pair".</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_conn_02"><title>DS_CONN_02 Sockets</title>
	    <sect3><title>Description</title>
		<simpara>
		    Socket is the complex CP - element that collects some CPs, EPs, and sockets. 
		    Like simple CP Socket is located in system or capsula of Incaps.
		    When connecting two sockets the observed hier element, normally Incapsulated system (Incaps)
		</simpara>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_ifcache"><title>Interfaces cache</title>
	<sect2 id="ds_ifcache_01"><title>DS_IFCACHE_01 Key scheme for cache</title>
	    <sect3><title>Description</title>
		<simpara>Current solution [6d15a3f2] uses key [Name, Requestor, Provider] where Requestor and Provider are pointers. This makes some limitation in
		    requests to cache. For instance the cases cannot be distinquished when agent is requested for iface from one and another conn points, 
		    because for agents cache the direct Requestor is agents host but not conn points. Refer to unit test ut_func_seq4.xml, agent of "Conv"
		    needs to distinquish requests from CP "Out" and CP "Out_WFarg" but it's not possible. Is is the indication of the current mechanism not
		    consistent? Do we need improvement of cache mechanism?</simpara>
	    </sect3>
	    <sect3 id="ds_ifcache_01_disc"><title>Discussion</title>
		<itemizedlist>
		    <listitem>A: No it is not. We simply need to adjust Conv to the scheme. The current implementation of Conv is not correct. </listitem>
		    <listitem>14Jul2013 Yes, the scheme is incorrect. It doesn't provide correct iface instance in case of request thru socket pin, 
			especially if pins are for the same iface, ref Ut_conn::test_Sock():58 [7618b16c5199]. The first step ut requested iface 
			MDIntGet from Cp1, socket "Out" updates cache with MDIntGet iface from Cp1. The second step ut requests iface
			from Cp2, but Out returns the previously cached iface because it cannot distinquish requestor.</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Solution: refuse ifaces caching approach at all, but use pseudo connections for all connpoints.</title>
		<simpara>Do we need caching really? Architecturally, caching is just establishing direct pseudo connections, that simplify an access
		    to iface instances. It is not confirmed that the overhead will be resonable for the case when we have the pseudo connections for 
		    totally all elements of system. Isn't better to use some intermediate scheme, where only some elements have it, for instance
		    only connpoints as they conduct most of communications.</simpara>
		<simpara>To implement this some specific iface for CP needs to be introduced: to get cp pair, to get iface from this pair host,
		    probably something else.</simpara>
		<simpara>Pros of this solution is that it is a bit simpler for understanding. Cons for the solution is that two steps needs for 
		    getting iface: step_1 is to get cp pair, step_2 is to get iface from this pair host.</simpara>
	    </sect3>
	    <sect3><title>Solution: extending of scheme by using full path from requestor.</title>
		<simpara></simpara> 
	    </sect3>
	    <sect3><title>Solution: to avoid having cache in agent (doesn't solve the problem actually)</title>
		<simpara>Original scheme seems resonable, the requests should be distinquish with even only level of requestor specified. 
		    The problem we faced is because of having agent as extra layer. Look at example we refeered in <xref linkend="ds_ifcache_01_disc"/>
		    Ut_conn::test_Sock():58. Ideally the "path" should be: Cp2 - L1 - Out - Cp2 - Data_2. But in reality we have:
		    Cp2 - L1 - Sock (agent) - Out - Sock (agent) .... So the link L1 - Sock (agent) eliminates the request distinquishness from Cp2. The 
		    question is "Can we avoid this cashe in agents?". This solution is also related to solution for agents, ref <xref linkend="ds_base_02"/></simpara>
		<simpara>No, it cannot solve the problem. Theer still will be sutuation where the one level requestor is not enough to correctly resolve
		    iface in cache. </simpara>
	    </sect3>
	    <sect3><title>Solution: using specific CP iface to get pair of socket's pin</title>
		<simpara>The idea is to fit CP with specific iface that provides getting "virtual" pair in case if CP is socket's pin.
		    Socket's pin requested for this iface, gets pair and redirect iface request to it. </simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_mut"><title>Mutations</title>
	<sect2 id="ds_mut_unappr"><title>Avoidng unappropriate mutations</title>
	    <sect3><title>Introduction</title>
		<simpara>Ref <ulink url="../requirements/index.html#uc_028"/> for use-case.</simpara>
		<simpara>Two structures are under operation when creating system: mutations tree and system native run-time hierarchy. Mutations are the
		    specification of the changes but native hier is the result of applying the mutaions sequence. The mutations are applied in the order
		    that is determined by the structures of mutations tree. The number of step when particular mutation will be applied is the mutations rank.</simpara>
		<simpara>Almost are mutations includes referece to some node of current native hier. These relations can be considered as dependencies network. 
		    Applying mutation Mn can brake the system if the mutaions is placed in unappropriate position within mutation tree. The brackage happens for
		    instance if the mutation related to node NN is placed in the position with the rank lower that rank of another mutation related to NN and
		    "not knowing" of the first mutation.</simpara>
		<simpara>Mutation tree has the node. The nodes that has leaves (non-terminal node) produces native hier node. Ref to mutation spec DTD to 
		    confirm that. Terminal nodes can be both node creation mutation and change mutations.</simpara>
		<simpara>What relations from mutation to hier node can be? They are specified in DTD: parent (mut "node"), object of change (mut "add, rm, change, cont"),
		    value (mut "change", "cont") </simpara>
		<simpara>So one way of preventing unappropriate mutation is to place it into the position with rank greater than the maximum rank of all
		    related to given node mutations. But how to get this maximum rank? The problem is that mutations are not run-time object that can be armed with
		    run-time relation. Mutations are just elements of chromo. So it is doubtful to create effective scheme of creating that relation network.</simpara>
		<simpara>The simplest solution (Biggest_rank) would be to add mutation to the biggest rank position in chromo, i.e at the end of roots chromo. 
		    In addition the mechainsm of mutations merging (squeezing or compacting of chromo) can be prepared that removes some mutation 
		    and replaces others to lower rank place.</simpara>
		<simpara>Another solution (Run_time_deps) is to collect all dependencies in run-time hier model: to mark the current node as dependent on some node
		    if the current node chromo includes mutation referred to the node. Basing on this data it is getting possible to find the max rank dependent 
		    chromo, so the current mutation is to be go to this chromo. The problem here is that creating of this dependencies network is complicated even
		    on run-time model level. The dependency is produced by any reference to the node, for instance by referring to node in URI extention part. </simpara>
	    </sect3>
	    <sect3><title>Rank</title>
		<simpara>We define rank as a vector the i-th element of which is the order of elements owner of i-th level.</simpara>
		<itemizedlist>
		    <listitem>Rank A is greater that rank B if A[i] > B[i] for some i. </listitem>
		    <listitem>We call the number of elements of rank tuple as depth of rank</listitem>
		    <listitem>We are saying that rank R is the rank of level N if N is R depth - 1. The lower level we call "higher" </listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Run_time_deps</title>
		<simpara>Theses</simpara>
		<orderedlist>
		    <listitem>In node Na depends on node Nb then Na depends also on owners and parents of node Nb. All owners and parents Nb must have lower
			rank that Nb. That means that we shouldn't take care of nodes specified in uri as prefix (owners, parents) including uri extention.</listitem>
		    <listitem>We can consider mutation as harmless if the mutation supplements run-time model. The following mutation are harmless: 
			node, add. We can consider a mutation as unsafe if the mutation change or reduces run-time model. Unsafe mutations are: rm, change, cont.</listitem>
		    <listitem>The register of deps in node Na contains all nodes that depends on node Na. So the client is able ot get the max rank of nodes that are
			dependent on the current node.</listitem>
		</orderedlist>
	    </sect3>
	    <sect3><title>Restrictions of mutations</title>
		<simpara>We introduce the restriction of mutations that can simplify the validation of mutations</simpara>
		<orderedlist>
		    <listitem>Rank depth of mutations must be less or equal of rank depth of mutated node </listitem>
		</orderedlist>
	    </sect3>
	</sect2>
    </sect1>

</article>
