<?xml version="1.0" ?>

<!DOCTYPE article SYSTEM "/usr/share/sgml/docbook/dtd/xml/4.5/docbookx.dtd">


<article status="draft" class="specification"> <title>Enhanced Discrete Events System framework (graph based). Design.</title>

    <articleinfo>
	<author><personname><firstname>Yuri</firstname><surname>Borisov</surname></personname>
	    <email>yuri.borisov.v@gmail.com</email></author> 

	<releaseinfo>Ver.0.05 at 18-Jan-2014</releaseinfo>

	<abstract>
	    <simpara>This document collects use-cases and software desing for Discrete Events System framework ver 2.</simpara>
	</abstract>

	<revhistory>
	    <revision> <revnumber>0.01</revnumber> <date>03-Mar-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Initial version</revremark> </revision>
	    <revision> <revnumber>0.02</revnumber> <date>21-Mar-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_conn_01"/></revremark> </revision>
	    <revision> <revnumber>0.03</revnumber> <date>06-Jul-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_ifcache"/></revremark> </revision>
	    <revision> <revnumber>0.04</revnumber> <date>14-Jul-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_base_02"/>. Updated <xref linkend="ds_ifcache_01"/></revremark> </revision>
	    <revision> <revnumber>0.05</revnumber> <date>18-Jan-2014</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_base_03"/></revremark> </revision>
	    <revision> <revnumber>0.06</revnumber> <date>10-Feb-2014</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_mut"/></revremark> </revision>
	</revhistory>

    </articleinfo>

    <bibliolist>
	<title>References</title>
    </bibliolist>


    <glossary> <title>Glossary</title> 

	<glossentry id="gls_cp"><glossterm>CP</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>Connection Point</para> <para>
		    Element that is used as endpoint of connections between systems.  
		    </para></glossdef> </glossentry>

    </glossary>
    
    <sect1 id="ds_base"> <title>Base</title>
	<sect2 id="ds_base_01"><title>DS_BASE_01 Getting iface</title>
	    <sect3><title>Description</title>
		<simpara>
		    In DES iface can be considered as atomic behavior. Getting iface is contained in base CPP APIs - GetObj. 
		    Many of components customize  that APIs. For instance the connection point is customizing the APIs to redirect
		    the request to real provider of the iface, for connpoint is a proxy only.
		</simpara>
		<simpara>Thus the redirection chain can be complex, so getting iface APIs should avoid looping. There could be several 
		    design approach:</simpara>
		<itemizedlist>
		    <listitem>Using agents extention mechanism. Redirect request to higher level of native hierarchy if the current level
		       cannot handle the request.	
		    </listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_base_02"><title>DS_BASE_02 Native behaviour. Agents.</title>
	    <sect3><title>Description</title>
		<simpara>The current implementation of elements extention for adding native bahavior is not consistent.</simpara>
	    </sect3>
	    <sect3><title>Discussion</title>
		<sect4><title>What are agents: component or internals of element.</title>
		    <simpara>Currently agents are implemented as components of element. Making them specific is done via collecting them in one
			specific part of element - "Agents" container. This solution foolows general approach of "cooperation" when the required complexity
			of system is secured via cooperation between elements. So extending of native behavior of element is done via cooperation of base
			element to embedded agents. But consequences of that is that agents are "regular" elements.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_base_03"><title>DS_BASE_03 Syntax of URI</title>
	    <simpara>The unified URI can be considered as node(s) determination request. The general form is as:</simpara>
	    <programlisting>
		uri = {"(" id_node_base_rel rel_sep ")"} node_name
	    </programlisting>
	    <simpara>Example is as:</simpara>
	    <programlisting>
		(hier_predecessor/)(inheritance_predecessor:)(vertex_pair~) name

		where:
		hier_predecessor - owner in base hierarchy
		/ - base hier separator - sign of base hier relation
		inheritance_predecessor - parent
		: - inheritance separator - sign of inheritance relation
		vertex_pair
		~ - vertex relation separator - sign of vertexes relations
	    </programlisting>
	    <simpara>So the uri is hierarchical (tree form) of relation specifying. This spec should be full enough to specify one node or set of nodes.</simpara> 
	    <simpara>The parentheseses are required to separate the branch of URI hierarchical tree. Having several layers in this tree causes the nested parentheseses that makes 
		this syntax rather incovenient even complete.
		The syntax of URI can be simplified in order to avoid parentheseses
		(they are very inconvenience indeed) by applying some restrictions to relations. For instance the currently used form of URI - GUri can be considered as
		the variant of generic form if we apply the restriction "chain of relation of some type can include only relation of this type". In this case the branches can 
		be resolved simply by relation type separator:</simpara>
	    <programlisting>
		n1/n2/n3/p3:p2:p1:node
	    </programlisting>
	    <simpara>No need to isolate the branch because the end of inheritance relation branch (p3:p2:p1) can be simply determined by changing of relation separator from ":" to "/"</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_conn"><title>Connections</title>
	<sect2 id="ds_conn_01"><title>DS_CONN_01 Connection points</title>
	    <sect3><title>Description</title>
		<simpara>
		    Connection points (CP) are endpoints of connections. System contains CPs and exhibits system's interfaces via CPs.
		</simpara>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_conn_03"><title>DS_CONN_03 CP interface</title>
	    <sect3><title>Description</title>
		<simpara>It is required for CPs to provide specific iface. One of the case where it can be used is
		    finding out "pair" of connection especially if sockets with deep hier are connected (also via extenders).
		    The problem when complex sockets is that some component within this hier is "virtually" connected
		    to some pair, but there is no simple mechanism to find the "pair".</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_conn_02"><title>DS_CONN_02 Sockets</title>
	    <sect3><title>Description</title>
		<simpara>
		    Socket is the complex CP - element that collects some CPs, EPs, and sockets. 
		    Like simple CP Socket is located in system or capsula of Incaps.
		    When connecting two sockets the observed hier element, normally Incapsulated system (Incaps)
		</simpara>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_ifcache"><title>Interfaces cache</title>
	<sect2 id="ds_ifcache_01"><title>DS_IFCACHE_01 Key scheme for cache</title>
	    <sect3><title>Description</title>
		<simpara>Current solution [6d15a3f2] uses key [Name, Requestor, Provider] where Requestor and Provider are pointers. This makes some limitation in
		    requests to cache. For instance the cases cannot be distinquished when agent is requested for iface from one and another conn points, 
		    because for agents cache the direct Requestor is agents host but not conn points. Refer to unit test ut_func_seq4.xml, agent of "Conv"
		    needs to distinquish requests from CP "Out" and CP "Out_WFarg" but it's not possible. Is is the indication of the current mechanism not
		    consistent? Do we need improvement of cache mechanism?</simpara>
	    </sect3>
	    <sect3 id="ds_ifcache_01_disc"><title>Discussion</title>
		<itemizedlist>
		    <listitem>A: No it is not. We simply need to adjust Conv to the scheme. The current implementation of Conv is not correct. </listitem>
		    <listitem>14Jul2013 Yes, the scheme is incorrect. It doesn't provide correct iface instance in case of request thru socket pin, 
			especially if pins are for the same iface, ref Ut_conn::test_Sock():58 [7618b16c5199]. The first step ut requested iface 
			MDIntGet from Cp1, socket "Out" updates cache with MDIntGet iface from Cp1. The second step ut requests iface
			from Cp2, but Out returns the previously cached iface because it cannot distinquish requestor.</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Solution: refuse ifaces caching approach at all, but use pseudo connections for all connpoints.</title>
		<simpara>Do we need caching really? Architecturally, caching is just establishing direct pseudo connections, that simplify an access
		    to iface instances. It is not confirmed that the overhead will be resonable for the case when we have the pseudo connections for 
		    totally all elements of system. Isn't better to use some intermediate scheme, where only some elements have it, for instance
		    only connpoints as they conduct most of communications.</simpara>
		<simpara>To implement this some specific iface for CP needs to be introduced: to get cp pair, to get iface from this pair host,
		    probably something else.</simpara>
		<simpara>Pros of this solution is that it is a bit simpler for understanding. Cons for the solution is that two steps needs for 
		    getting iface: step_1 is to get cp pair, step_2 is to get iface from this pair host.</simpara>
	    </sect3>
	    <sect3><title>Solution: extending of scheme by using full path from requestor.</title>
		<simpara></simpara> 
	    </sect3>
	    <sect3><title>Solution: to avoid having cache in agent (doesn't solve the problem actually)</title>
		<simpara>Original scheme seems resonable, the requests should be distinquish with even only level of requestor specified. 
		    The problem we faced is because of having agent as extra layer. Look at example we refeered in <xref linkend="ds_ifcache_01_disc"/>
		    Ut_conn::test_Sock():58. Ideally the "path" should be: Cp2 - L1 - Out - Cp2 - Data_2. But in reality we have:
		    Cp2 - L1 - Sock (agent) - Out - Sock (agent) .... So the link L1 - Sock (agent) eliminates the request distinquishness from Cp2. The 
		    question is "Can we avoid this cashe in agents?". This solution is also related to solution for agents, ref <xref linkend="ds_base_02"/></simpara>
		<simpara>No, it cannot solve the problem. Theer still will be sutuation where the one level requestor is not enough to correctly resolve
		    iface in cache. </simpara>
	    </sect3>
	    <sect3><title>Solution: using specific CP iface to get pair of socket's pin</title>
		<simpara>The idea is to fit CP with specific iface that provides getting "virtual" pair in case if CP is socket's pin.
		    Socket's pin requested for this iface, gets pair and redirect iface request to it. </simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_ifcache_refr"><title>Refreshing cache on node change.</title>
	    <sect3><title>Introduction</title>
		<simpara>Ref to <ulink url="../requirements/index.html#uc_010"/> for use-case related.</simpara>
		<simpara>Ifaces cache needs to be updated properly if some new ifaces got appeared or disappeared in result of mutations. 
		    Currently this functionality is not implemented properly.
		    The only cache invalidation is doing when vertex gets connected or disconnected.</simpara>
		<simpara>The initial idea is that the mutated node needs to know all its iface requestors and to notify all of them 
		    about nodes change that can affect iface providing. 
		    There are forward relations from requester to servece nodes (such nodes that provide the ifaces): 
		    each agent knows to what node of hier to redirect the request. But currently
		    there is no back relations from service node to requesters. 
		    This is because unsuccessful request doesn't go to chache so the node doesn't know of the requester further.</simpara>
	    </sect3>
	    <sect3><title>Proposed solution</title>
		<itemizedlist>
		    <listitem>To register requests anycase in order to keep all relations requestor-provider even if
			provider couldn't resolve the request this time. This will allow to subsequently invalidate caches by the
			chain from provider to all requestors. So the requestor will re-request iface.</listitem>
		    <listitem>To implement mechanism of unregistering of requests. This is required to keep the relations
			acutal, for instance if some node is deleted, all the corresponding requests needs to be unregistered.</listitem>
		    <listitem>To invalidate the cache of the given node we need to unregister the requests from this node cache, propagating
			this process in both directions: to requestor and to providers. The simplest mechanism seems to be unregister in some
			node of this propagation chain not only requests corresponding to given provider but all the requests with that context.
			In this case we simply unregister the whole request that depends on the initial invalidated provider.  </listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_mut"><title>Mutations</title>
	<sect2 id="ds_mut_unappr"><title>Avoidng unappropriate mutations</title>
	    <sect3><title>Rank</title>
		<simpara>We define rank as a vector the i-th element of which is the order of elements owner of i-th level.</simpara>
		<itemizedlist>
		    <listitem>Rank A is greater that rank B if A[i] > B[i] for some i. </listitem>
		    <listitem>We call the number of elements of rank tuple as depth of rank</listitem>
		    <listitem>We are saying that rank R is the rank of level N if N is R depth - 1. The lower level we call "higher" </listitem>
		</itemizedlist>
	    </sect3>
	    <sect3 id="ds_mut_unappr_intro"><title>Introduction</title>
		<simpara>Ref <ulink url="../requirements/index.html#uc_028"/> for use-case.</simpara>
		<simpara>Two structures are under operation when creating system: mutations tree and system native run-time hierarchy. Mutations are the
		    specification of the changes but native hier is the result of applying the mutaions sequence. The mutations are applied in the order
		    that is determined by the structures of mutations tree. The number of step when particular mutation will be applied is the mutations rank.</simpara>
		<simpara>Almost are mutations includes reference to some node of current native hier. These relations can be considered as dependencies network. 
		    Applying mutation Mn can brake the system if the mutaions is placed in unappropriate position within mutation tree. The brackage happens for
		    instance if the mutation related to node NN is placed in the position with the rank lower that rank of another mutation related to NN and
		    "not knowing" of the first mutation.</simpara>
		<simpara>Below is the example of mutation braking system consistency:
		    <figure id="fig_mut_uappr_intro_ex1"><imageobject> <imagedata fileref="pics/pic_mut_uc1.png"/> </imageobject></figure>
		</simpara>
		<simpara>Mutation tree has the node. The nodes that has leaves (non-terminal node) produces native hier node. Ref to mutation spec DTD to 
		    confirm that. Terminal nodes can be both node creation mutation and change mutations.</simpara>
		<simpara>What relations from mutation to hier node can be? They are specified in DTD: 
		    <orderedlist>
			<listitem> parent (mut "node") </listitem>
			<listitem id="ds_mut_unappr_intro_dep_obj"> object of change (mut "add, rm, change, cont") </listitem>
			<listitem id="ds_mut_unappr_intro_dep_ref"> reference (value "id" in mut "cont") </listitem>
		    </orderedlist>
		</simpara>
		<simpara>So one way of preventing unappropriate mutation is to place it into the position with rank greater than the maximum rank of all
		    related to given node mutations. But how to get this maximum rank? The problem is that mutations are not run-time object that can be armed with
		    run-time relation. Mutations are just elements of chromo. So it is doubtful to create effective scheme of creating that relation network.</simpara>
		<simpara>The simplest solution (Biggest_rank) would be to add mutation to the biggest rank position in chromo, i.e at the end of roots chromo. 
		    In addition the mechainsm of mutations merging (squeezing or compacting of chromo) can be prepared that removes some mutation 
		    and replaces others to lower rank place.</simpara>
		<simpara>Another solution (Run_time_deps) is to collect all dependencies in run-time hier model: to mark the current node as dependent on some node
		    if the current node chromo includes mutation referred to the node. Basing on this data it is getting possible to find the max rank dependent 
		    chromo, so the current mutation is to be go to this chromo. The problem here is that creating of this dependencies network is complicated even
		    on run-time model level. The dependency is produced by any reference to the node, for instance by referring to node in URI extention part. </simpara>
	    </sect3>
	    <sect3 id="ds_mut_unappr_rt"><title>Run_time_deps</title>
		<simpara>Theses</simpara>
		<orderedlist>
		    <listitem id="ds_mut_unappr_rt_ths1">If node Na depends on node Nb then Na depends also on owners and parents of node Nb. All owners and parents Nb must have lower
			rank that Nb. That means that we shouldn't take care of nodes specified in uri as prefix (owners, parents) including uri extention.</listitem>
		    <listitem>If node Na depends on node Nb then all children of Na also depend on Nb.</listitem>
		    <listitem>We can consider mutation as harmless if the mutation supplements run-time model. The following mutation are harmless: 
			node, add. We can consider a mutation as unsafe if the mutation change or reduces run-time model. Unsafe mutations are: rm, change, cont.</listitem>
		    <listitem>The register of deps in node Na contains all nodes that depends on node Na. So the client is able ot get the max rank of nodes that are
			dependent on the current node.</listitem>
		    <listitem>The dependant is actually the mutation, but only mutation within run-time node (there can be mutaion in some node but it is possible 
			that it doesn't reflect any node in run-time model, for instance if some root node is mutated first by adding component node and than by
			removing it - all mutation within adding component node part of chromo will not be in run-time. 
			Mutations are not reflecing directly to run-time model even -node-.
			So the dependency can be defined as the node which chromo containg mutation plus mutation rank in chromo. Another solution could be to 
			define dependency directly as mutaion.</listitem>
		    <listitem>There are deps "model-on-chromo" and "chromo-on-model". We can consider the type of dep as the type of mut argument</listitem>
		    <listitem>We need to consider not only simple deps but chain of deps. The example of chain is inheritance chain, node3 on node1:
			<programlisting>
			    mut1 on node1 as -parent-
			    node2 on mut1 as -id-
			    mut2 on node2 as -parent-
			    node3 on mut2 as -id-
			</programlisting>
		    </listitem>
		</orderedlist>
		<simpara>So the algorithm of taking into account dependencies for mutation of type -rm- is as:</simpara>
		<itemizedlist>
		    <listitem>Get the node being removed </listitem>
		    <listitem>From this node get the major dependent node - the dependent node with biggest rank. The depencend node is run-time node containing dependent mutation, 
			or child of this node (ref Theses) or child of node being removed.</listitem>
		    <listitem>Mutate the dependency instead of initial node.</listitem>
		</itemizedlist>
		<simpara>Below is shown the example of using dependencies</simpara>
		<figure id="fig_mut_uappr_intro_ex2"><imageobject> <imagedata fileref="pics/pic_mut_uc2.png"/> </imageobject></figure>
	    </sect3>
	    <sect3><title>Restrictions of mutations</title>
		<simpara>We introduce the restriction of mutations that can simplify the validation of mutations</simpara>
		<orderedlist>
		    <listitem>Rank depth of mutations of dependency type "object" and "parameter" (ref <xref linkend="ds_mut_unappr_intro_dep_obj"/>, 
			<xref linkend="ds_mut_unappr_intro_dep_ref"/>) must be less or equal of rank depth of mutated node. 
			In other words the object of mutation must be owned of node that contains the mutations. </listitem>
		    <listitem>It is not allowed to remove a node if the node has childs. This restriction can be removed in the future. Currently it is 
			not supporting of creating child when some parent in parents chain is missed. Potentially
			there is no fundamental problem with removing parent. But even in this case we need to take into account the childs as the deps.</listitem>
		</orderedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_rm_prnt"><title>Deleting of parent- how to keep system consistency [uc_029]</title>
	    <sect3><title>Criticizm</title>
		<simpara>Seems the current scheme of creation node is totally inconsistent with principles of incremental creation. The scheme
		    is working but the problem is that it is based on run-time parents that is not always real case. More correct scheme would be that
		    basing on non-run-time parents, i.e. on chromos. This would be working for all the cases.</simpara>
	    </sect3>
	    <sect3><title>Possible solutions</title>
		<sect4><title>To check the parent - if run-time parent doesn't exist then get its chromo from system chromo.</title>
		    <simpara>This approach goes to using parent's chromo instead of run-time nodes as is in current solution. Can we use chromo? The doubts are
			because of the incremental mutation scheme principle "Chromosome as subject and system as object of creation". 
			This means that the references in chromo (to object node, to parent etc.) are the references within system but not within chromo itserf.</simpara>
		    <simpara>Usecase is: root node N_R, its comp N_A contains N_A_1, then N_A gets removed, creator makes mutation in N_R to create N_B for that this N_A_1 is in parents chain. 
			The problem here is that even we get N_A_1 chromo to mutate, the mutation has to be done in context of N_A that is also removed. So the references from
			mutations within N_A_1 chromo to internals of N_A are broken. How the mutaion with chromo N_A_1 can be done? It shuldn't be a problem if we take into 
			account the principle "Mutations references of types other than -parent- can point only to onwned node". This means that the mutation within N_A_1 can 
			contains references only inside of N_A_1. The only parent reference can be to outside of local conext, but as was discussed parents relation is safe in root chromo.</simpara>
		    <simpara>The weaknes of this solution is that it requires that parents chromo node can be found from the node being mutated with -node- mutation. So 
			we need to have ChromoNode methods like GetNode, the analogue of such method in run-time Elem. But chromo has only one explicit relations net - native hierarchy of
			ownership. Chromo doesn't support hierarchy of inheritance. This makes the problem to use this approach because inheritance based URIs cannot be resolved in chromo. </simpara>
		</sect4>
		<sect4><title>To not actually remove run-time node but mark it as removed</title>
		    <simpara>Node having this mark shall deny any mutations. The clients should ignore and hide "removed" nodes.</simpara>
		    <simpara>Weaknesses?</simpara>
		    <itemizedlist>
			<listitem> Seems just workaround. </listitem>
			<listitem>Comp is not deleted actually, so it is kept in owner comps register. This can cause problem with multiple choice when resolving component. 
			    Currently the following mutation is quite popular, in Extender for instance: to remove default Int and to create custom Int. But in this case there will be two Ints.</listitem>
		    </itemizedlist>
		</sect4>
	    </sect3>
	    <sect3><title>QnA</title>
	    </sect3>
	</sect2>
	<sect2 id="ds_rn_prnt"><title>Renaming of parent - how to keep system consistency [uc_031]</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <ulink url="../requirements/index.html#uc_031"/> for use-case</simpara>
	    </sect3>
	    <sect3><title>Analysis</title>
		<simpara>Current implementation is just notify the owner of renaming, so owner makes the correction into components register. UC_031 is not considered currently.
		    But it seems there is no fundamental limitation as for removing of parent, ref <xref linkend="ds_rm_prnt"/>. This is because the parent is accessible from child
		    node in runtime. The only problem is that currently the child refers to parent via chromo data on creation heir, ref Elem::CreateHeir.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_mv_local"><title>Local Moving of node.</title>
	    <sect3><title>Intro</title>
		<simpara>Actually local moving of node is not single mutation but two mutations: re-creating node in new context and removing initial node.</simpara>
	    </sect3>
	    <sect3><title>How to transform chromo for new context</title>
		<simpara>One of the problem when re-creating node in new context is transformation node's chromo to be sutable for new context. </simpara>
		<simpara>There can be some solution considered. One of them is to transform source node chromo to destination node context. This approach is rather complicated for
		    implementation. Another approach is to use currently implemented mechanism of creatng heir. So we can create heir from source node (this is done by source node 
		    in original context, so doesn't cause any troubles. Then we can re-adopt the heir from source node to its parent.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Moving of node</title>
	</sect2>
	<sect2 id="ds_mut_sqeezing"><title>Squeezing of mutations</title>
	    <sect3><title>Intro</title>
		<simpara>Squeezing of mutation seems at the first glance obvious and simple. Indeed, if there are two adjacent renamings the same node then why we cannot
		    remove the first one because its effect is completelly eliminated by the mutation following. So generalizing this particular case to all the mutations we
		    can go to the simple idea that all mutations can be checked for being excessive and removed or maybe merged. But this simple idea became not realistic on
		    detailed analysis. </simpara>
	    </sect3>
	    <sect3><title>Approaches: reverse engineering</title>
		<simpara>One of the approach for squeezing the mutaions is: as the result of all mutations is the created system, then all what we need is to get the system,
		    and "regenerate" the mutatation from the system, i.e. to do kind of "reverse engineering". The problem here is that is is not possible to do it by using some
		    simple algorithm. First of all there is no possibility to "eliminate" any mutation applied to part of node that comes from parent, so called detached chromo. 
		    But these mutations can have references to node that then changed by further muatinons. Let's look at the example:</simpara>
		<programlisting>
		    add node="node_1" {
		    node id=node_1_0 parent="some_node"
		    }
		    rename node="some_node" val="some_node_renamed"
		</programlisting>
		<simpara>So there is no way to restore the -add- mutation from model. In other words the "outer" mutations aka "phenotype" are ambuguous, so we cannot say from what they 
		    were applied. So no possibility to recreate them from the model.</simpara>
	    </sect3>
	    <sect3><title>Approaches: Direct merging.</title>
		<simpara>Let's assume that we have all relations between the model and mutaions in chromo. There are relations of two directions: rt node to mutations and mutations to node. This 
		    allows getting relations quickly from both parts.
		    The relations includes the reference to muation, and the type, ref <xref linkend="ds_mut_unappr_intro"/> </simpara>
		<simpara>The algorithm of squeezing chromo of the given RT node would be like outlined below. For clarity aim let's consider the particular mutation, -rn-:</simpara>
		<orderedlist>
		    <listitem>Start from the second mutation (remember the first is -node- itself)</listitem>
		    <listitem>Check if the mutation can be squeezed. For -rn NODE_X- the checking passes be default because there must be mutation -node- with lower rank.</listitem>
		    <listitem>Go thru all mutations  depending on NODE_X and which rank lies between initial -node- and given -rn-: correct the reference to NODE_X according to -rn- paramenter.</listitem>
		</orderedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_drv_int"><title>How to derive from component of heirs</title>
	    <sect3><title>Introduction</title>
		<simpara>Currently the following mechanism is used for derivation. Node [N] that is adding component [(CP:)C]  gets components parent [CP], requests it to produce the child in its own context,
		    relocate the created child to nodes hier, and then applies the mutations [CM] to the components. Note that the mutation applied to the component are being done in
		    node [N] context. It causes the following problem: when some system [S] uses node [N] as parent for derivation new node [N~1] then [N~1] will have another component [C] 
		    (it is also named [C] but it is not the same [C] as [N] has). This component [C] chromo [CM] is related to node [N] context. </simpara>
		<simpara>Ref to diagram below.</simpara>
		<figure id="fig_mut_drv_int1"><imageobject> <imagedata fileref="pics/pic_ds_mut_drv_from_comp.png"/> </imageobject></figure>
		<simpara>So it happens that CM/C is not suited for derivation because its chromo is for another context. To generalize: the components that were came to child from parent in derivation process are
		    not sutable for inheritance if the childs context differs from parents context. How to deal with this case?</simpara>
		<simpara>There could be the following approaches suggested:</simpara>
		<itemizedlist>
		    <listitem>To detect if the components is suitable for inheritance, i.e. if some of its owners were moved from original context.</listitem>
		    <listitem>To modify of creating of new node: to truly relocate the heir, not only change the owner. Ref <xref linkend="ds_drv_int_rel"/> for details</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3 id="ds_drv_int_rel"><title>Approaches: To modify of creating of new node</title>
		<simpara>Currently to relocation of created heir to new hier is being done quite simple, ref. elem.cpp/Elem::CreateHeir()/Relocate heir to hier ... The only 
		    new owner is set for created heir, no any corrections in mutations referred to original context.</simpara>
	    </sect3>
	</sect2>

    </sect1>

</article>
