<?xml version="1.0" ?>

<!DOCTYPE article SYSTEM "/usr/share/sgml/docbook/dtd/xml/4.5/docbookx.dtd">


<article status="draft" class="specification"> <title>Enhanced Discrete Events System framework (multiagents based). Design.</title>

    <articleinfo>
	<author><personname><firstname>Yuri</firstname><surname>Borisov</surname></personname>
	    <email>yuri.borisov.v@gmail.com</email></author> 

	<releaseinfo>Ver.0.11 at 08-Mar-2015</releaseinfo>

	<abstract>
	    <simpara>This document collects use-cases and software desing for Discrete Events System framework ver 2.</simpara>
	</abstract>

	<revhistory>
	    <revision> <revnumber>0.01</revnumber> <date>03-Mar-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Initial version</revremark> </revision>
	    <revision> <revnumber>0.02</revnumber> <date>21-Mar-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_conn_01"/></revremark> </revision>
	    <revision> <revnumber>0.03</revnumber> <date>06-Jul-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_ifcache"/></revremark> </revision>
	    <revision> <revnumber>0.04</revnumber> <date>14-Jul-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_base_02"/>. Updated <xref linkend="ds_ifcache_01"/></revremark> </revision>
	    <revision> <revnumber>0.05</revnumber> <date>18-Jan-2014</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_base_03"/></revremark> </revision>
	    <revision> <revnumber>0.06</revnumber> <date>10-Feb-2014</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_mut"/></revremark> </revision>
	    <revision> <revnumber>0.07</revnumber> <date>08-Aug-2014</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_nat_agent_hier"/></revremark> </revision>
	    <revision> <revnumber>0.08</revnumber> <date>09-Sep-2014</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_mut_dis_pheno"/>, <xref linkend="ds_mut_pheno"/></revremark> </revision>
	    <revision> <revnumber>0.09</revnumber> <date>29-Sep-2014</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_transp"/></revremark> </revision>
	    <revision> <revnumber>0.10</revnumber> <date>26-Oct-2014</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_agt_data"/></revremark> </revision>
	    <revision> <revnumber>0.11</revnumber> <date>08-Mar-2015</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_ifnegot"/></revremark> </revision>
	    <revision> <revnumber>0.12</revnumber> <date>14-Apr-2015</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="ds_mod"/></revremark> </revision>
	</revhistory>

    </articleinfo>

    <bibliolist>
	<title>References</title>

	<biblioentry id="ref_incr_mut"> <abbrev>INCR_MUT</abbrev>
	    <productname><ulink url="../../../fap-doc/doc_incr_syst_creation/index.html "/></productname>
	    <title>Y.Borisov. Using incremental mutation process for systems modeling</title> </biblioentry>

	<biblioentry id="ref_rfc_3986"> <abbrev>RFC_3986_URI</abbrev>
	    <productname><ulink url="http://www.ietf.org/rfc/rfc3986.txt"/></productname>
	    <title>RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</title> </biblioentry>

    </bibliolist>


    <glossary> <title>Glossary</title> 

	<glossentry id="gls_cp"><glossterm>CP</glossterm> <acronym>CP</acronym>
	    <glossdef> <para>Connection Point</para> <para>
		    Element that is used as endpoint of connections between systems.  
		    </para></glossdef> </glossentry>

    </glossary>
    
    <sect1 id="ds_base"> <title>Base</title>
	<sect2 id="ds_base_01"><title>DS_BASE_01 Getting iface</title>
	    <sect3><title>Description</title>
		<simpara>
		    In DES iface can be considered as atomic behavior. Getting iface is contained in base CPP APIs - GetObj. 
		    Many of components customize  that APIs. For instance the connection point is customizing the APIs to redirect
		    the request to real provider of the iface, for connpoint is a proxy only.
		</simpara>
		<simpara>Thus the redirection chain can be complex, so getting iface APIs should avoid looping. There could be several 
		    design approach:</simpara>
		<itemizedlist>
		    <listitem>Using agents extention mechanism. Redirect request to higher level of native hierarchy if the current level
		       cannot handle the request.	
		    </listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_base_02"><title>DS_BASE_02 Native behaviour. Agents.</title>
	    <sect3><title>Description</title>
		<simpara>The current implementation of elements extention for adding native bahavior is not consistent.</simpara>
	    </sect3>
	    <sect3><title>Discussion</title>
		<sect4><title>What are agents: component or internals of element.</title>
		    <simpara>Currently agents are implemented as components of element. Making them specific is done via collecting them in one
			specific part of element - "Agents" container. This solution foolows general approach of "cooperation" when the required complexity
			of system is secured via cooperation between elements. So extending of native behavior of element is done via cooperation of base
			element to embedded agents. But consequences of that is that agents are "regular" elements.</simpara>
		</sect4>
	    </sect3>
	</sect2>
	<sect2 id="ds_base_03"><title>DS_BASE_03 Syntax of URI</title>
	    <simpara>The unified URI can be considered as node(s) determination request. The general form is as:</simpara>
	    <programlisting>
		uri = {"(" id_node_base_rel rel_sep ")"} node_name
	    </programlisting>
	    <simpara>Example is as:</simpara>
	    <programlisting>
		(hier_predecessor/)(inheritance_predecessor:)(vertex_pair~) name

		where:
		hier_predecessor - owner in base hierarchy
		/ - base hier separator - sign of base hier relation
		inheritance_predecessor - parent
		: - inheritance separator - sign of inheritance relation
		vertex_pair
		~ - vertex relation separator - sign of vertexes relations
	    </programlisting>
	    <simpara>So the uri is hierarchical (tree form) of relation specifying. This spec should be full enough to specify one node or set of nodes.</simpara> 
	    <simpara>The parentheseses are required to separate the branch of URI hierarchical tree. Having several layers in this tree causes the nested parentheseses that makes 
		this syntax rather incovenient even complete.
		The syntax of URI can be simplified in order to avoid parentheseses
		(they are very inconvenience indeed) by applying some restrictions to relations. For instance the currently used form of URI - GUri can be considered as
		the variant of generic form if we apply the restriction "chain of relation of some type can include only relation of this type". In this case the branches can 
		be resolved simply by relation type separator:</simpara>
	    <programlisting>
		n1/n2/n3/p3:p2:p1:node
	    </programlisting>
	    <simpara>No need to isolate the branch because the end of inheritance relation branch (p3:p2:p1) can be simply determined by changing of relation separator from ":" to "/"</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_conn"><title>Connections</title>
	<sect2 id="ds_conn_01"><title>DS_CONN_01 Connection points</title>
	    <sect3><title>Description</title>
		<simpara>
		    Connection points (CP) are endpoints of connections. System contains CPs and exhibits system's interfaces via CPs.
		</simpara>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_conn_03"><title>DS_CONN_03 CP interface</title>
	    <sect3><title>Description</title>
		<simpara>It is required for CPs to provide specific iface. One of the case where it can be used is
		    finding out "pair" of connection especially if sockets with deep hier are connected (also via extenders).
		    The problem when complex sockets is that some component within this hier is "virtually" connected
		    to some pair, but there is no simple mechanism to find the "pair".</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_conn_02"><title>DS_CONN_02 Sockets</title>
	    <sect3><title>Description</title>
		<simpara>
		    Socket is the complex CP - element that collects some CPs, EPs, and sockets. 
		    Like simple CP Socket is located in system or capsula of Incaps.
		    When connecting two sockets the observed hier element, normally Incapsulated system (Incaps)
		</simpara>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_ifcache"><title>Interfaces cache</title>
	<sect2 id="ds_ifcache_01"><title>DS_IFCACHE_01 Key scheme for cache</title>
	    <sect3><title>Description</title>
		<simpara>Current solution [6d15a3f2] uses key [Name, Requestor, Provider] where Requestor and Provider are pointers. This makes some limitation in
		    requests to cache. For instance the cases cannot be distinquished when agent is requested for iface from one and another conn points, 
		    because for agents cache the direct Requestor is agents host but not conn points. Refer to unit test ut_func_seq4.xml, agent of "Conv"
		    needs to distinquish requests from CP "Out" and CP "Out_WFarg" but it's not possible. Is is the indication of the current mechanism not
		    consistent? Do we need improvement of cache mechanism?</simpara>
	    </sect3>
	    <sect3 id="ds_ifcache_01_disc"><title>Discussion</title>
		<itemizedlist>
		    <listitem>A: No it is not. We simply need to adjust Conv to the scheme. The current implementation of Conv is not correct. </listitem>
		    <listitem>14Jul2013 Yes, the scheme is incorrect. It doesn't provide correct iface instance in case of request thru socket pin, 
			especially if pins are for the same iface, ref Ut_conn::test_Sock():58 [7618b16c5199]. The first step ut requested iface 
			MDIntGet from Cp1, socket "Out" updates cache with MDIntGet iface from Cp1. The second step ut requests iface
			from Cp2, but Out returns the previously cached iface because it cannot distinquish requestor.</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Solution: refuse ifaces caching approach at all, but use pseudo connections for all connpoints.</title>
		<simpara>Do we need caching really? Architecturally, caching is just establishing direct pseudo connections, that simplify an access
		    to iface instances. It is not confirmed that the overhead will be resonable for the case when we have the pseudo connections for 
		    totally all elements of system. Isn't better to use some intermediate scheme, where only some elements have it, for instance
		    only connpoints as they conduct most of communications.</simpara>
		<simpara>To implement this some specific iface for CP needs to be introduced: to get cp pair, to get iface from this pair host,
		    probably something else.</simpara>
		<simpara>Pros of this solution is that it is a bit simpler for understanding. Cons for the solution is that two steps needs for 
		    getting iface: step_1 is to get cp pair, step_2 is to get iface from this pair host.</simpara>
	    </sect3>
	    <sect3><title>Solution: extending of scheme by using full path from requestor.</title>
		<simpara></simpara> 
	    </sect3>
	    <sect3><title>Solution: to avoid having cache in agent (doesn't solve the problem actually)</title>
		<simpara>Original scheme seems resonable, the requests should be distinquish with even only level of requestor specified. 
		    The problem we faced is because of having agent as extra layer. Look at example we refeered in <xref linkend="ds_ifcache_01_disc"/>
		    Ut_conn::test_Sock():58. Ideally the "path" should be: Cp2 - L1 - Out - Cp2 - Data_2. But in reality we have:
		    Cp2 - L1 - Sock (agent) - Out - Sock (agent) .... So the link L1 - Sock (agent) eliminates the request distinquishness from Cp2. The 
		    question is "Can we avoid this cashe in agents?". This solution is also related to solution for agents, ref <xref linkend="ds_base_02"/></simpara>
		<simpara>No, it cannot solve the problem. Theer still will be sutuation where the one level requestor is not enough to correctly resolve
		    iface in cache. </simpara>
	    </sect3>
	    <sect3><title>Solution: using specific CP iface to get pair of socket's pin</title>
		<simpara>The idea is to fit CP with specific iface that provides getting "virtual" pair in case if CP is socket's pin.
		    Socket's pin requested for this iface, gets pair and redirect iface request to it. </simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_ifcache_refr"><title>Refreshing cache on node change.</title>
	    <sect3><title>Introduction</title>
		<simpara>Ref to <ulink url="../requirements/index.html#uc_010"/> for use-case related.</simpara>
		<simpara>Ifaces cache needs to be updated properly if some new ifaces got appeared or disappeared in result of mutations. 
		    Currently this functionality is not implemented properly.
		    The only cache invalidation is doing when vertex gets connected or disconnected.</simpara>
		<simpara>The initial idea is that the mutated node needs to know all its iface requestors and to notify all of them 
		    about nodes change that can affect iface providing. 
		    There are forward relations from requester to servece nodes (such nodes that provide the ifaces): 
		    each agent knows to what node of hier to redirect the request. But currently
		    there is no back relations from service node to requesters. 
		    This is because unsuccessful request doesn't go to chache so the node doesn't know of the requester further.</simpara>
	    </sect3>
	    <sect3><title>Proposed solution</title>
		<itemizedlist>
		    <listitem>To register requests anycase in order to keep all relations requestor-provider even if
			provider couldn't resolve the request this time. This will allow to subsequently invalidate caches by the
			chain from provider to all requestors. So the requestor will re-request iface.</listitem>
		    <listitem>To implement mechanism of unregistering of requests. This is required to keep the relations
			acutal, for instance if some node is deleted, all the corresponding requests needs to be unregistered.</listitem>
		    <listitem>To invalidate the cache of the given node we need to unregister the requests from this node cache, propagating
			this process in both directions: to requestor and to providers. The simplest mechanism seems to be unregister in some
			node of this propagation chain not only requests corresponding to given provider but all the requests with that context.
			In this case we simply unregister the whole request that depends on the initial invalidated provider.  </listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_mut"><title>Mutations</title>
	<sect2 id="ds_mut_unappr"><title>Avoidng unappropriate mutations</title>
	    <sect3><title>Rank</title>
		<simpara>We define rank as a vector the i-th element of which is the order of elements owner of i-th level.</simpara>
		<itemizedlist>
		    <listitem>Rank A is greater that rank B if A[i] > B[i] for some i. </listitem>
		    <listitem>We call the number of elements of rank tuple as depth of rank</listitem>
		    <listitem>We are saying that rank R is the rank of level N if N is R depth - 1. The lower level we call "higher" </listitem>
		</itemizedlist>
	    </sect3>
	    <sect3 id="ds_mut_unappr_intro"><title>Introduction</title>
		<simpara>Ref <ulink url="../requirements/index.html#uc_028"/> for use-case.</simpara>
		<simpara>Two structures are under operation when creating system: mutations tree and system native run-time hierarchy.
		    Mutations are the specification of the changes but native hier is the result of applying the mutaions sequence.
		    The mutations are applied in the order that is determined by the structures of mutations tree.
		    The number of step when particular mutation will be applied is the mutations rank.</simpara>
		<simpara>Almost are mutations includes reference to some node of current native hier.
		   These relations can be considered as dependencies network. 
		   Applying mutation Mn can brake the system if the mutaions is placed in unappropriate position within mutation tree.
		   The brackage happens for instance if the mutation related to node NN is placed in the position with the rank 
		   lower that rank of another mutation related to NN and "not knowing" of the first mutation.</simpara>
		<simpara>Below is the example of mutation braking system consistency:
		    <figure id="fig_mut_uappr_intro_ex1"><imageobject> <imagedata fileref="pics/pic_mut_uc1.png"/> </imageobject></figure>
		</simpara>
		<simpara>Mutation tree has the node. The nodes that has leaves (non-terminal node) produces native hier node. 
		    Ref to mutation spec DTD to confirm that. Terminal nodes can be both node creation mutation and change mutations.</simpara>
		<simpara>What relations from mutation to hier node can be? They are almost directly related to mutation
		    attribures specified in DTD: 
		    <orderedlist>
			<listitem> creation (attr ENa_Id in mut "node") </listitem>
			<listitem> parent (attr ENa_Parent in mut "node") </listitem>
			<listitem id="ds_mut_unappr_intro_dep_obj"> object of change (attr ENa_Node in mut "node, rm, change, cont") </listitem>
			<listitem id="ds_mut_unappr_intro_dep_ref"> reference (arrt ENa_Ref in mut "cont") </listitem>
		    </orderedlist>
		</simpara>
		<simpara>So one way of preventing unappropriate mutation is to place it into the position with rank greater than 
		    the maximum rank of all related to given node mutations. But how to get this maximum rank? The problem is 
		    that mutations are not run-time object that can be armed with run-time relation. Mutations are just elements of chromo. 
		    So it is doubtful to create effective scheme of creating that relation network.</simpara>
		<simpara>The simplest solution (Biggest_rank) would be to add mutation to the biggest rank position in chromo,
		    i.e at the end of roots chromo.  In addition the mechainsm of mutations merging (squeezing or compacting of chromo) 
		    can be prepared that removes some mutation and replaces others to lower rank place.</simpara>
		<simpara>Another solution (Run_time_deps) is to collect all dependencies in run-time hier model: to mark the current node 
		    as dependent on some node if the current node chromo includes mutation referred to the node. Basing on this 
		    data it is getting possible to find the max rank dependent chromo, so the current mutation is to go to this chromo. 
		    The problem here is that creating of this dependencies network is complicated even
		    on run-time model level. The dependency is produced by any reference to the node, for instance by referring to node 
		    in URI extention part. </simpara>
	    </sect3>
	    <sect3 id="ds_mut_unappr_rt"><title>Run_time_deps</title>
		<simpara>We need to clarify the term "relation" used earlier. We will say that run-time node Na depends on mutation Mb. 
		    This make sense in terms that run-time node is "object" of change but mutation is "subject" of change.</simpara>
		<simpara>Theses</simpara>
		<orderedlist>
		    <listitem id="ds_mut_unappr_rt_ths1"> If node Na depends on mut Mb then also owners and parents of Na depends on mut Mb. 
			<simpara>
			Prove for owner:  if there is owner No and it's comp Nc and mut Mc of Nc, then for instance mut of removing
			No should go after Mc.
			Prove for parent: There is parent Np and it's child Nc, and there is mut Mc of Nc containgin URI including parent,
			then for instance mut Mp of renaming Np should go after Mc otherwise Mc will be broken.
			</simpara>
			<simpara>There are different "nature" of these deps. Some of them are created because of referencing via
			    URI, and that uri "trace" include the node. If the trace is going thru inheritance tree that deps parents via
			    childs created as mentioned above.</simpara>
		    </listitem>
		    <listitem id="ds_mut_unappr_rt_ths2"> If node Na depends on mut Mb then all children and components of Na also depend on Mb. 
			<simpara> Proving case for parent: mut Mp changing parent or owner changes URI ref to it, so changes ref to childs
			    and comps. So any mut of childs and comps should go after Mp, i.e with bigger rank. Example: node No contains it's
			    copnonent Nc. There is mut Mo of No of renaming No. So any mut of Nc that ident Nc via URI including Nc name should
			    go after Mo.
			</simpara>
		    </listitem>
		    <listitem>Basing on theses [<xref linkend="ds_mut_unappr_rt_ths1"/>] and [<xref linkend="ds_mut_unappr_rt_ths2"/>] 
			we see that to check dependencies of any node N in native hier we
			need to check it's whole comp and inher branches in the hier.</listitem>
		    <listitem>We can consider mutation as harmless if the mutation supplements run-time model. The following mutation are harmless: 
			node, add. We can consider a mutation as unsafe if the mutation change or reduces run-time model. 
			Unsafe mutations are: rm, change, cont.</listitem>
		    <listitem>The register of deps in node Na contains all mutations (plus nodes containing that mutation) that depends 
			on node Na. So the client is able to get the max rank of nodes that are dependent on the current node.</listitem>
		    <listitem>The dependant is actually the mutation, but only mutation within run-time node (there can be mutaion in 
			some node but it is possible that it doesn't reflect any node in run-time model, for instance if some root node 
			is mutated first by adding component node and than by removing it - all mutation within adding component node part 
			of chromo will not be in run-time.  Mutations are not reflecing directly to run-time model even -node-.
			So the dependency can be defined as the node which chromo containg mutation plus mutation itself in chromo.</listitem>
		    <listitem>There are deps "model-on-chromo" and "chromo-on-model". We can consider the type of dep as the type 
			of mut argument</listitem>
		    <listitem>We need to consider not only simple deps but chain of deps. The example of chain is inheritance chain, node3 on node1:
			<programlisting>
			    mut1 on node1 as -parent-
			    node2 on mut1 as -id-
			    mut2 on node2 as -parent-
			    node3 on mut2 as -id-
			</programlisting>
		    </listitem>
		</orderedlist>
		<simpara>So the algorithm of taking into account dependencies for mutation of type -rm- is as:</simpara>
		<itemizedlist>
		    <listitem>Get the node being removed </listitem>
		    <listitem>From this node get the major dependent node - the dependent node with biggest rank. The depencend node is 
			run-time node containing dependent mutation, or child of this node (ref Theses) or child of node being removed.</listitem>
		    <listitem>Mutate the dependency instead of initial node.</listitem>
		</itemizedlist>
		<simpara>Below is shown the example of using dependencies</simpara>
		<figure id="fig_mut_uappr_intro_ex2"><imageobject> <imagedata fileref="pics/pic_mut_uc2.png"/> </imageobject></figure>
	    </sect3>
	    <sect3><title>Restrictions of mutations</title>
		<simpara>We introduce the restriction of mutations that can simplify the validation of mutations</simpara>
		<orderedlist>
		    <listitem>Rank depth of mutations of dependency type "object" and "parameter" (ref <xref linkend="ds_mut_unappr_intro_dep_obj"/>, 
			<xref linkend="ds_mut_unappr_intro_dep_ref"/>) must be less or equal of rank depth of mutated node. 
			In other words the object of mutation must be owned of node that contains the mutations. </listitem>
		    <listitem>It is not allowed to remove a node if the node has childs. This restriction can be removed in the future. 
			Currently it is not supporting of creating child when some parent in parents chain is missed. Potentially
			there is no fundamental problem with removing parent. But even in this case we need to take into account the childs 
			as the deps.</listitem>
		</orderedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_rm_prnt"><title>Deleting of parent- how to keep system consistency [uc_029]</title>
	    <sect3><title>Criticizm</title>
		<simpara>Seems the current scheme of creation node is totally inconsistent with principles of incremental creation. The scheme
		    is working but the problem is that it is based on run-time parents that is not always real case. More correct scheme would be that
		    basing on non-run-time parents, i.e. on chromos. This would be working for all the cases.</simpara>
	    </sect3>
	    <sect3><title>Possible solutions</title>
		<sect4><title>To check the parent - if run-time parent doesn't exist then get its chromo from system chromo.</title>
		    <simpara>This approach goes to using parent's chromo instead of run-time nodes as is in current solution.
		       Can we use chromo? The doubts are
			because of the incremental mutation scheme principle "Chromosome as subject and system as object of creation". 
			This means that the references in chromo (to object node, to parent etc.) are the references within system but 
			not within chromo itserf.</simpara>
		    <simpara>Usecase is: root node N_R, its comp N_A contains N_A_1, then N_A gets removed, creator makes mutation in 
			N_R to create N_B for that this N_A_1 is in parents chain. 
			The problem here is that even we get N_A_1 chromo to mutate, the mutation has to be done in context of N_A 
			that is also removed. So the references from
			mutations within N_A_1 chromo to internals of N_A are broken. How the mutaion with chromo N_A_1 can be done? 
			It shuldn't be a problem if we take into 
			account the principle "Mutations references of types other than -parent- can point only to onwned node". 
			This means that the mutation within N_A_1 can 
			contains references only inside of N_A_1. The only parent reference can be to outside of local conext, 
			but as was discussed parents relation is safe in root chromo.</simpara>
		    <simpara>The weaknes of this solution is that it requires that parents chromo node can be found from the 
			node being mutated with -node- mutation. So 
			we need to have ChromoNode methods like GetNode, the analogue of such method in run-time Elem. 
			But chromo has only one explicit relations net - native hierarchy of
			ownership. Chromo doesn't support hierarchy of inheritance. This makes the problem to use this approach 
			because inheritance based URIs cannot be resolved in chromo. </simpara>
		</sect4>
		<sect4><title>To not actually remove run-time node but mark it as removed</title>
		    <simpara>Node having this mark shall deny any mutations. The clients should ignore and hide "removed" nodes.</simpara>
		    <simpara>Weaknesses?</simpara>
		    <itemizedlist>
			<listitem> Seems just workaround. </listitem>
			<listitem>Comp is not deleted actually, so it is kept in owner comps register. This can cause problem with 
			    multiple choice when resolving component. 
			    Currently the following mutation is quite popular, in Extender for instance: to remove default Int 
			    and to create custom Int. But in this case there will be two Ints.</listitem>
		    </itemizedlist>
		</sect4>
	    </sect3>
	    <sect3><title>QnA</title>
	    </sect3>
	</sect2>
	<sect2 id="ds_rn_prnt"><title>Renaming of parent - how to keep system consistency [uc_031]</title>
	    <sect3><title>Intro</title>
		<simpara>Ref <ulink url="../requirements/index.html#uc_031"/> for use-case</simpara>
	    </sect3>
	    <sect3><title>Analysis</title>
		<simpara>Current implementation is just notify the owner of renaming, so owner makes the correction into components register. UC_031 is not considered currently.
		    But it seems there is no fundamental limitation as for removing of parent, ref <xref linkend="ds_rm_prnt"/>. This is because the parent is accessible from child
		    node in runtime. The only problem is that currently the child refers to parent via chromo data on creation heir, ref Elem::CreateHeir.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_mv_local"><title>Local Moving of node.</title>
	    <sect3><title>Intro</title>
		<simpara>Actually local moving of node is not single mutation but two mutations: 
		    re-creating node in new context and removing initial node.</simpara>
	    </sect3>
	    <sect3><title>How to transform chromo for new context</title>
		<simpara>One of the problem when re-creating node in new context is transformation node's chromo to be 
		    sutable for new context. </simpara>
		<simpara>There can be some solution considered. One of them is to transform source node chromo to destination node context. 
		    This approach is rather complicated for
		    implementation. Another approach is to use currently implemented mechanism of creatng heir. 
		    So we can create heir from source node (this is done by source node 
		    in original context, so doesn't cause any troubles. Then we can re-adopt the heir from source node to its parent.</simpara>
	    </sect3>
	    <sect3><title>Is operation of local movement useful?</title>
		<simpara>The problem here is that the current implementation [ff62b4f15279edfbe4baf36161d3dcad6973725f] 
		    the result of local movement is run-time only. It is 
		    clear, we just need to remember that local movement is specified by simple mutation within the chromo.
		    So there are doubts that local movement is actually useful. There
		    were no occurances at the moment of using this local movement operation.
		</simpara>
		<simpara>There is alternative approach, ref <xref linkend="ds_mut_cutncopy"/></simpara>
	    </sect3>
	</sect2>
	<sect2><title>Moving of node</title>
	</sect2>
	<sect2 id="ds_transp"><title>Nodes (mutations) transposition (reordering)</title>
	    <sect3><title>Intro</title>
		<simpara> Nodes transposition, or nodes shifting is just changing the order the nodes in the 
		    owner node. The order is inportant for model creation because actually the model creation "machine" is single-pass. 
		    So the mutation that use reference to some node must be applied AFTER the referenced node is created.</simpara>
		<simpara>There was the discussion around this operation, 
		    ref <ulink url="../../../fap-doc/doc_incr_syst_creation/index.html#sec_lim_transp"/>. There was conclusion
		that transposition is not allowed in the scope of incremental mutations approach.</simpara>
	    </sect3>
	    <sect3><title>Approached</title>
		<simpara>There are potential solution for the problem of changing order:</simpara>
		<orderedlist>
		    <listitem>Not consider changing order as chromo mutaion, ref <xref linkend="ds_transp_nochange"/></listitem>
		    <listitem>Add specific mutation, improve ordering mechanism, ref <xref linkend="ds_transp_mut"/></listitem>
		</orderedlist>
	    </sect3>
	    <sect3 id="ds_transp_nochange"><title>Approach: Not consider changing order as chromo mutaion </title>
		<simpara>The disadvantage here is that there will not be the history of change.</simpara>
	    </sect3>
	    <sect3 id="ds_transp_mut"><title>Mutation for transposition instead of direct changing of chromo</title>
		<simpara>The decision that transposition is not allowed in incremental mutation scheme is based on the assumption that
		    the transposition is done via direct chromo changing. But it is still possible to change the order without 
		    direct changing of chromo. The idea is that the mutation can be used, that specifies the change of order.  </simpara>
		<simpara>In this case we still follow the incremental mutaions approach and the same time can change the order. 
		    Another point is that the mutaion mechanism needs to be improved to support the change order mutation. This is 
		    because the mechanism should operate not only with the current mutation as usual but take into account all nodes
		    in the current upper level node and "create" the order before adding the nodes. There is also the option of 
		    inserting the order change mutation at the beginning of the upper level node.</simpara>
		<simpara>One of the solution could be as following. The -node- mutation includes specific element - container of reordering mutations. This element should be the first
		    within -node-. Reordering mutation is like: 'order' object_order target_order, where object order is the initial order of reordered mutation and target order is initial order of 
		    mutation before that the reordered mutation is shifted. The initial order is id of native order of mutation in owned node, i.e the order of mutation in local chromo. When -node- mutation
		    gets applied, the mutated agent first calculate the order of mutations using reodreding mutations and then applies the mutaion according to new order. In result the chromo of 
		    agent will be reordered. To keep chromo original this reordered chromo needs to be transformed back to unordered state on chromo saving.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_mut_dis_pheno"><title>Disabling/Enabling phenotypic modificaions</title>
	    <sect3><title>Intro</title>
		<simpara>Last time there was decision made to introduce new options - disabling pheno modificaions</simpara>
	    </sect3>
	    <sect3><title>Cause of the problem</title>
		<simpara>The root-cause of the problem is contradiction between the sequence of changing model and 
		    option of inheritance of childs from the structural part of system native hier. If we didn't require 
		    such an inheritance then we can use flat chromo where the order of mutations completelly corresponds to
		    the order the changes applied to the system on construction phase.</simpara>
	    <simpara>However native hier (structure) is very important part of system creation and cannot be
		avoided or ignored. This approach is to create the system via a set of components, which are
		improved via inheritance and local mutations. According to this approach the mutation in parent must
		be applied before the childs creation. But this mutation applying sequence differs from native secuence 
		(the sequence of how the mutation were introduced)</simpara>
	    <simpara>Actually to keep original sequence is not a problem. For instance flat chromo can be used.</simpara>
	    <simpara>There is another option of keeping the original sequence of mutation - mutation order. 
		Currently it is possible to set order value for each mutation. So if the "chromo machine" could to
		apply the muts according to the order it would be equivalent to flat chromo. Equivelency means that these
		forms of chromos can be explicitly transformed one to another.</simpara>
		<simpara>But again the real problem is that approach of creating system via inherited sybsystems requires that
		the sequence of applying differs the original sequence.</simpara>
	    </sect3>
	    <sect3><title>Inheritance based approach: solving the problems.</title>
		<simpara>Currently inherirance based approach is the primary mechanism for creation system. The problem of 
		    not keeping the original sequence in this case can be mitigated by disabling phenotypic modification. What
		    are the theats of breaking chromo safety:
		    <itemizedlist>
			<listitem>Changing ref: dependencies on the local owner comonent with the bigger rank.
			    This problem can be fixed by shifting mutated node root mutation over to dependency mutation. This will
			    not affect the model because this shifting is local.  </listitem>
			<listitem>Renaming subnode that is referenced. No solution here, required change of ref.</listitem>
		    </itemizedlist>
		</simpara>
	    </sect3>
	    <sect3><title>Flat chromo approach</title>
		<simpara>Issues</simpara>
		<orderedlist>
		    <listitem>What if we create child from a node and then apply some mutation to the node. Then we d like to
			have this mutaion in child also.</listitem>
		</orderedlist>
	    </sect3>
	    <sect3><title>Issues</title>
		<orderedlist>
		    <listitem>In case of pheno disabled it will not be possible to change parents but keep childs out of this change. 
			Currently (enabled pheno) it
			is possible to change parent even after there was children created. Then potentially we have an option to 
			"rebase" children via moving pheno to mutation. In case of pheno disabled we need to refuse any mutations in 
			parent or enable the mut, so do "rebasing" immediatelly. In fact this "immediate" rebasing is exact 
			approach of system creation using inheritance.</listitem>
		</orderedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_mut_pheno"><title>Controlling of Phenotypic modification mode</title>
	    <sect3><title>Introduction</title>
		<simpara>Initially phenotypic modification was enabled by default. On practice this mode was rather
		    inconvenient because of pheno modifs created a lot of dependencies. To keep chromo safe we transform many changes 
		    to pheno modif and put them after corresponding deps. In result the constructed system chromo
		    become mess. Also this hardened inheritance - the changes that should be real mutations were transformed to
		    pheno modif that were not involved in inheritance process.</simpara>
		<simpara>After this problem analysis it was decided that we need to restrict the pheno modif mode and have
		    pheno modif disabled by default. Only for inherited nodes the pheno modif would be enabled in this case	.</simpara>
		<simpara>But this decision also resulted in problem. For instance it got not possible to simply change 
		    ref in Edges connpoint. So if some edge was created with low rank and then it became required to make connection
		    to node with greated rank then it result in critical dependency. There were two approached considered: 
		    <itemizedlist>
			<listitem>to move edge locally in order to increase edges rank</listitem>
			<listitem>to introduce the ability to set pheno mode for particular agent.</listitem>
		    </itemizedlist>
		</simpara>
	    </sect3>
	    <sect3><title>Shifting node to increase its rank</title>
		<simpara>This approach cons is that actually it is not possible to do it via simple mutation. It was discussed 
		    many times, ref <xref linkend="ref_incr_mut"/> for the discusstion, specifically the section
		    "Transposition of nodes within chromo is not allowed". Also ref <xref linkend="ds_transp"/> for the design 
		    related discussion. The short explanation is that the initial mutaion anytime goes first so to change nodes rank we
		    need to edit chromo but not mutation it additivelly.</simpara>
		<simpara>So to shift the node we need to recreate the node, remove initial one and then squeeze the chromo to 
		    avoid errors reporting because of initial mut is failed. Not simple approach really.</simpara>
	    </sect3>
	    <sect3><title>How to set pheno mode for an agent</title>
		<simpara>The most realistic approach is to add specific new attribute of node and to add specific Elem API, like
		    IsPhenoEnabled(). Agent will be able have its own default value for this attribute. For instance Edge agent
		    could set this attribute as enabled.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_mut_sqeezing"><title>Squeezing of mutations</title>
	    <sect3><title>Intro</title>
		<simpara>Squeezing of mutation seems at the first glance obvious and simple. Indeed, if there are two adjacent renamings the same node then why we cannot
		    remove the first one because its effect is completelly eliminated by the mutation following. So generalizing this particular case to all the mutations we
		    can go to the simple idea that all mutations can be checked for being excessive and removed or maybe merged. But this simple idea became not realistic on
		    detailed analysis. </simpara>
	    </sect3>
	    <sect3><title>Approaches: reverse engineering</title>
		<simpara>One of the approach for squeezing the mutaions is: as the result of all mutations is the created system, 
		    then all what we need is to get the system,
		    and "regenerate" the mutatation from the system, i.e. to do kind of "reverse engineering". 
		    The problem here is that is is not possible to do it by using some
		    simple algorithm. First of all there is no possibility to "eliminate" any mutation applied to part of node 
		    that comes from parent, so called detached chromo. 
		    But these mutations can have references to node that then changed by further muatinons. Let's look at the example:</simpara>
		<programlisting>
		    add node="node_1" {
		    node id=node_1_0 parent="some_node"
		    }
		    rename node="some_node" val="some_node_renamed"
		</programlisting>
		<simpara>So there is no way to restore the -add- mutation from model. In other words the "outer" mutations 
		    aka "phenotype" are ambuguous, so we cannot say from what they 
		    were applied. So no possibility to recreate them from the model.</simpara>
	    </sect3>
	    <sect3><title>Approaches: Direct merging.</title>
		<simpara>Let's assume that we have all relations between the model and mutaions in chromo. There are relations of two directions: rt node to mutations and mutations to node. This 
		    allows getting relations quickly from both parts.
		    The relations includes the reference to muation, and the type, ref <xref linkend="ds_mut_unappr_intro"/> </simpara>
		<simpara>The algorithm of squeezing chromo of the given RT node would be like outlined below. For clarity aim let's consider the particular mutation, -rn-:</simpara>
		<orderedlist>
		    <listitem>Start from the second mutation (remember the first is -node- itself)</listitem>
		    <listitem>Check if the mutation can be squeezed. For -rn NODE_X- the checking passes be default because there must be mutation -node- with lower rank.</listitem>
		    <listitem>Go thru all mutations  depending on NODE_X and which rank lies between initial -node- and given -rn-: correct the reference to NODE_X according to -rn- paramenter.</listitem>
		</orderedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_drv_int"><title>How to derive from component of heirs</title>
	    <sect3><title>Introduction</title>
		<simpara>Currently the following mechanism is used for derivation. Node [N] that is adding component [(CP:)C]  gets components parent [CP], requests it to produce the child in its own context,
		    relocate the created child to nodes hier, and then applies the mutations [CM] to the components. Note that the mutation applied to the component are being done in
		    node [N] context. It causes the following problem: when some system [S] uses node [N] as parent for derivation new node [N~1] then [N~1] will have another component [C] 
		    (it is also named [C] but it is not the same [C] as [N] has). This component [C] chromo [CM] is related to node [N] context. </simpara>
		<simpara>Ref to diagram below.</simpara>
		<figure id="fig_mut_drv_int1"><imageobject> <imagedata fileref="pics/pic_ds_mut_drv_from_comp.png"/> </imageobject></figure>
		<simpara>So it happens that CM/C is not suited for derivation because its chromo is for another context. To generalize: the components that were came to child from parent in derivation process are
		    not sutable for inheritance if the childs context differs from parents context. How to deal with this case?</simpara>
		<simpara>There could be the following approaches suggested:</simpara>
		<itemizedlist>
		    <listitem>To detect if the components is suitable for inheritance, i.e. if some of its owners were moved from original context.</listitem>
		    <listitem>To modify of creating of new node: to truly relocate the heir, not only change the owner. Ref <xref linkend="ds_drv_int_rel"/> for details</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3 id="ds_drv_int_rel"><title>Approaches: To modify of creating of new node</title>
		<simpara>Currently to relocation of created heir to new hier is being done quite simple, ref. elem.cpp/Elem::CreateHeir()/Relocate heir to hier ... The only 
		    new owner is set for created heir, no any corrections in mutations referred to original context.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_mut_cutncopy"><title>Chromo cutncopy: do we need it?</title>
	    <sect3><title>Intro</title>
		<simpara>There are some usecases clearly indicated that copy of chromo is useful operation. One of cases is:
		    USER has some complex model and he wants to separate some part of this model as independent model.</simpara>
	    </sect3>
	    <sect3><title>Cons</title>
		<itemizedlist>
		    <listitem>Doesn't support of simple undo. This is because copy operation is not single mutaion but series of mutations.</listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_indp_mutord"><title>Independence on local mutations order</title>
	    <sect3><title>Refs</title>
		<itemizedlist>
		    <listitem>Use case: <ulink url="../requirements/index.html#uc_046"/></listitem>
		    <listitem>Use case: <ulink url="../requirements/index.html#uc_050"/></listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extra UC: Refusing of mut with non-resolvable unsafety</title>
		<simpara>Main usecase is that new mutation is checked for safety and SYSTEM repositions the mutations
		    in case if unsafety is detected. But what if mutation introduces unsafety that cannot be fixed?
		    This can be the case of cyclic dependencies for instance.</simpara>
		<simpara>Assuming that initially there is no cycles in the node. So the procedure would be as:
		    Checking if new mutation introduce a cycle into the node, is so then refuse it.</simpara>
		<simpara>To prove: If there are no cycles in the node then it is not possible to creaty any cycle via
		    re-positioning the node components.</simpara>
		<simpara>To prove: If there are no cycles int the node then the node components can be ordered to have 
		    only backword dependencies.</simpara>
	    </sect3>
	    <sect3 id="ds_indp_mutord_impl"><title>Taking in consideration implicit dependencies</title>
		<simpara>Refer to use case <ulink url="../requirements/index.html#uc_050"/> for details.</simpara>
		<simpara>The base approach of shifting mutation is as:</simpara>
		<itemizedlist>
		    <listitem>System founds the dependency for given mutation</listitem>
		    <listitem>System get common owner for given mutation and the dependency</listitem>
		    <listitem>System shift in the common owner the node containing given mutation over the node containing the dep.</listitem>
		</itemizedlist>
		<simpara>The first step here is most important. According to use-case not only the explicit dependencies are to be taken into
		    account but also implicit. These implicit dependencies are specific of agent and cannot be resolved by default.</simpara>
		<simpara>Let's look at the agent "Edge" (the scenario is exactly described in use-case ref). The agent itself doesn't expose
		    some specific dependencies, because of being just almost "passive" owner of pair of references. But real "creator" the
		    implicit dependencies here is the system owning the edge. This is because the connection point compatibility checking is being done
		by onwning system but not the edge itself. Exaclty on the checking the dependency is become apparent.</simpara>
	    <simpara>How would be the approach of checking the implicit dependency in this case ? The approach would be like this:</simpara>
	    <itemizedlist>
		<itemizedlist>Supposing the base agent (Elem) has the virtual method "GetImplicitDeps", which default implementation
		is just run "GetMajorDep" and if no dep found, just redirect it to its owner.</itemizedlist>
		<listitem>Edge gets mutation. Edge runs GetImplicitDeps, that just is redirected to edges owner - the system.</listitem>
		<listitem>The system analyses the request, understands that the initial mutation is the change of edges point, so 
		asks the points ref to get the deps</listitem>
	    </itemizedlist>
	    <simpara>This approach has one defect: just having virtual agent method will not work. The reason is that the deps are not determine 
		by agent itself but by the role the agent plays in its owner. For instance, ConnectionPoint agent can be referenced within vertes 
		as just vertex but not Connectable. So as a vertex ConnectionPoint doesn't have some specifics for deps. But if it is referenced
		within system, then it becomes specific deps as Connectable. So Connectable has to have its own method for deps.
	    </simpara>
	    <simpara>Also it needs to be considered if all mutation require asking owner to find implicit deps. As we see the implicit deps are 
		generated by run-time behaviour, i.e by agents specific. Let's look at what parts of mutation require knowledge of deps. As we 
		already discussed the dep is actually dep runtime node on another dep. So saying "what are the deps for the given mutation" we
		have to say "what are the deps for all runtime nodes referenced by this mutation". There are three kinds of runtime nodes 
		references in mutations: object, parent, and ref. What refs can generate implicit deps in agents? To answer this question we
		need to look at which references are specifically handled by agents. All such handling is initiated via MCompsObserver iface. The
		review of the current handling implementation is as: </simpara>
	    <programlisting>
		Syst::OnCompDeleting - object
		OnCompAdding - default handling only
		OnCompChanged - many agents hadnling change of ref in content. So - ref
		OnCompRenamed - default handling only
	    </programlisting>
	    <simpara>So at the moment the only specific deps for mutation nodes referenced via ref attribute have to be taken into account.</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_mut_attach"><title>Concept of nodes chromo attaching</title>
	    <sect3 id="ds_mut_attach_calc"><title>Attaching sign calculation</title>
		<simpara>Currently the concept of nodes chromo attaching is actively used. There is base agents proper APIs for that: IsChromoAttached.
		    We say that nodes chromo is attached if there is path from nodes chromo to system chromo root node. But currently the attaching sign
		    is calculated a bit incorrectly. In result the nodes not directly attached but placed to component are not considered as attached, example is: 
		    [node node=some_component parent=some_parent name=some_name]. This causes problem when pheno modification disabled: on one hand such node 
		    is detected as not attached so its attached owner is selected as the mutation point,
		    on another hand the error "attempt of pheno modif, disabled" occurs because the node isn't inherited.</simpara>
	    </sect3>
	    <sect3><title>Attaching node and ownining node</title>
		<simpara>It makes sense to consider also relation of attaching. So the let's call "attaching node" the node that chromo is attaching of 
		    given node chromo. This attaching node also is some level owner of given node but not necessary direct owner. For direct mutation of 
		    type "node" (i.e. the mutation that doesn't have argument "node") the attaching owner is direct owner. To simplify the referring, let's
		    use to following abbreviation:
		    <itemizedlist>
			<listitem> Acomp - component attached to the given node.
			    <simpara>Acomp is also component but not necessary direct.</simpara> </listitem>
			<listitem>Aowner - near owner attaching the given node.
			    <simpara>Aowner is owner but not necessary direct owner.  </simpara></listitem>
		    </itemizedlist>
		</simpara>
	    </sect3>
	</sect2>
	<sect2 id="ds_mut_refs"><title>References: rules and limitations</title>
	    <simpara>References are important part of relation in systems native topology (hier + inher). Establishing rules and limitations for
		referencing can significantly affects the topology. Currently the only limitation is that rank of referenced node has to be less than the 
		referencing one. What rules and llimitation can be applied?</simpara>
       	</sect2>
    </sect1>

    <sect1 id="ds_visrepr"><title>Visual representation</title>
	<sect2><title>Introduction</title>
	    <simpara>Visual representation here is not visualization of model like falling ball pictures for the ball model.
		The representation is of how to show the structure of model for the user, so it can be described as structure visual representation.</simpara>
	    <itemizedlist>
		<listitem>Ref <ulink url="../requirements/index.html#uc_036"/> for use-case</listitem>
	    </itemizedlist>
	</sect2>
	<sect2 id="ds_visrepr_emb"><title>Approaches: embedded into agent base</title>
	    <simpara>This approach is to extend agent base to support visial representation hint. This can be done by adding specific attribute to agent specification.</simpara>
	    <simpara>Pros:</simpara>
	    <itemizedlist>
		<listitem>Doesn't increase the complexity of the system. Any agent will keep it's representation data.</listitem>
		<listitem>Base mechanism of mutation will be used for modification, so rollback will be supported simply.</listitem>
	    </itemizedlist>
	    <simpara>Cons:</simpara>
	    <itemizedlist>
		<listitem>The value of the dedicated attribute can be quite long, so the mutations can become ineffective. </listitem>
	    </itemizedlist>
	</sect2>
	<sect2 id="ds_visrepr_dea"><title>Approaches: using dedicated agent for the representation</title>
	    <simpara>The dedicated agent is created to keep the parameters of visual representation. This approach doesn't differ much from 
		<xref linkend="ds_visrepr_emb"/>, the only change is that instead of having the support of representation in base agent (i.e. 
		in each agent), we add specific representation agent into nodes that requires custom visualization.</simpara>
	</sect2>
	<sect2 id="ds_visrepr_mdl"><title>Approaches: representation to be described by means of model itself</title>
	    <sect3><title>Intro</title>
		<simpara>When we talking of representation we mean some relations between part of system. For instance the visual order of
		    system components actually the ordered relation of these components set. So the question is why these relations are not part of the
		    model? We can also refer to visualization of the model, when we create specific model for visual part, e.g. specific widged for 
		    ball moving area. We can do thame thing for structure visual representation.</simpara>
		<simpara>There can be objections here that these specific relations are valuable for some clients that use visual representation but for some not.
		    These relations doesn't affect "functional", behavioural aspects of system at all. But the same question is actual for the other approaches
		    also: all the information kept by specific attribute of agent base in <xref linkend="ds_visrepr_emb"/> or in dedicated agent for
		    <xref linkend="ds_visrepr_dea"/> is not needed for system behavior.</simpara>
	    </sect3>
	    <sect3><title>How to mix agents for general behaviour and representation</title>
		<simpara>So the proposal here can be to have mechanism of "switching off" those part of the model that we are not interested in at the
		    moment. For instance if we just running the system and looking just at some local part of the model (e.g. visualization part) so
		    we don't need the part related to structure visual representation. This separation can be implemented by having one base element for 
		    all representation agents, plus env option to not create those, plus support of creation masking on agent base level.</simpara>
		<simpara>How to avoid dependencies beween general and representational agents? The idea is to keep all representational agents
		    together, e.g in one agent. This would allow to simplify the structure of the whole system.</simpara>
	    </sect3>
	    <sect3><title>Representational agents</title>
		<simpara>The following agents could be used for visual representation:</simpara>
		<itemizedlist>
		    <listitem>Low-level ordering relationship. It could be used to order components within a node.</listitem>
		    <listitem>Reference. This can be used for compact representation for displaying the data of node. 
			This is already used, but not reference, just uri of data node.</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Ordered relationalship agent. How to implement.</title>
		<simpara>Currently there is already scheme of how to create ordered relationalship. For this the general approach is used:
		    "relation is neutral, the relation specific goes thru system role". So there is agent "Edge" for neutral relation, specific
		    agent "Vert" for object of relation, and 
		    system agent that supports roles can be used for 
		    ordering relationship: system should have roles "lower" and "bigger". This approach allows effective requesting for 
		    relation: client can as any system for "all nodes bigger than you". System just gives to client the request 
		    for iface set of "bigger".</simpara>
		<simpara>The disadvantage of this approach is that only system can be used but not lower layer agents, like vertex.</simpara>
		<simpara>One of the alternative approach is to use specific relation agent, not neutral. In this case simple vertex agent
		    can be the object of specific relation.
		</simpara>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_refl_idir"><title>Reflecting of direction of information</title>
	<sect2><title>Intro</title>
	    <simpara>Ref <ulink url="../requirements/index.html#uc_040"/> for the use-case.</simpara>
	</sect2>
	<sect2 id="sec_refl_idir_whatdiris"><title>What CP direction is?</title>
	    <simpara>For the first glance CP direcition is the only hint of how to represent system to clear show information handling stages. But actually
		not only this. The direction also create the limitations of connections. For connecting systems: output to input, input to output.
		For connecting system boundary to internal nodes: boundary input to internal input, internal output to boundary output.  </simpara>
	    <simpara>So CP direction is the paremeter of CP that needs to be used to check CP compatibility.</simpara>
	</sect2>
	<sect2><title>Approaches</title>
	    <orderedlist>
		<listitem>To introduce fake customized agents for CPs.
		    <simpara>Here we are saying: "Any CP can be used for getting info or passing it out. Even CP itself doesn't know of that and is not customizing to 
			to it specifically, we "marking" them so the system using it can indicate this CP specialization.</simpara>
		</listitem>
		<listitem>To customize systems boundary: to introduce specific parts "Input" and "Output" in capsule.
		    <simpara>The idea is that system is responsible for moving data thru, so the system can customize its structure to indicate the CPs 
			specialization.  </simpara>
		</listitem>
		<listitem>To consider <xref linkend="sec_refl_idir_whatdiris"/>:  To have all CPs base implementing MCompatChecker (by the way why not rename 
		    this iface to something like "MConn"?). To add to this iface method GetDir().</listitem>
	    </orderedlist>
	</sect2>
    </sect1>

    <sect1 id="ds_nat_agent_hier"><title>How to embed native agents into agents hierarchy</title>
	<sect2><title>Refs</title>
	    <itemizedlist>
		<listitem>Use case: <ulink url="../requirements/index.html#uc_045"/></listitem>
	    </itemizedlist>
	</sect2>
	<sect2><title>Intro</title>
	    <simpara>All the agents are to have their place in agents hierarhy, so can be pointed to via
		hierarchy coordinate (uri). Currently there are two hierarchies defined: structural, induced by relation
		"component-container" and inheritance hierarchy, induced by relation "parent-child". Both heirarchies are 
		supported by capability of base agent "Elem" to establish relations of both types. Each hierarchy has 
		initial point - root. So there are structural root, agent that doesn't have container to be related to, and
		inheritance root - element that doesn't have parent.</simpara>
	    <simpara>It is obvious that inheritance root is the base agent - Elem. As for structural hierarchy, currently any 
		derived agent can be root. The problem here is that native agents, those that are delivered by environment, are
		not embedded into structural hierarchy, but has no structural root, so logically are considered as structural
		roots theirself. So we got multiple structural root that makes troubles when referencing to the agents via 
		structural coordinates.
	    </simpara>
	    <simpara>We need to take into account specifics of native agents as parent. Normally we specify ref to parent assuming
		the parent exists and can be reached via ref in the proper hierarchy. But for native agent it is not true. It is 
		possible that the agent doesn't exist yet, in this case it will be created by the environment. Currently we even
		use specific form of uri, w/o hier relation symbol when referencing to native agent. Also there is dedicated
		mechanism of gettng the native agent unregarding from hierarchies - from environment native agents cache.</simpara>
	</sect2>
	<sect2><title>Approach: To allow mutlitpe structural roots</title>
	    <simpara>This is what currently exists. To support this we need to update Elem method of gettng structural node.
		But this is not simple. This is because algorithm of gettng node is based on single root. In other words root is
		entry point for getting node.</simpara>
	</sect2>
	<sect2><title>Approach: To have specific node for native agents in structural hierarchy.</title>
	    <simpara>There is the problem with this approach: to create root we already should have base agent available.
		But according to the approach this agent should be part of root. This causes logical contradiction.</simpara>
	</sect2>
	<sect2><title>Approach: To have base agents as both structural and inheritance hierarchies.</title>
	    <simpara>This options does't seem to have some contradictions. The only problem is that we need to have
		additional node. Morover this node needs to be deattached. Also we need to support ref to this node on
		environment level to be able of adding newly created native agents (ref Elem::AddElem) to this node.
	    </simpara>
	</sect2>
	<sect2><title>Approach: don't have native agents in structural hierarchy</title>
	    <simpara>This is mainly how it works now. We are saying that native agents are not in structural hierarchy but
		can be obtained via inherirance hierarchy uri or simple native agents uri. It should work, we just need to
		ensure clear distinction of native agents ref (uri). Currently native agents uri form doesn't distinct from
		form of default structural uri (for it also no relation symbol is used in uri, ref GUri::Parse)</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_agt_data"><title>Agents for data</title>
	<sect2 id="ds_agt_data_repr"><title>Data string representation scheme</title>
	    <programlisting>
		data_repr = type , ":" value
		type = type_signature , "," , type_parameters
	    </programlisting>
	    <itemizedlist>
		<listitem>type_signature is primarily type identifier. It assosiates to type implementation where type_parameters are served as paremeters of 
		    type implementation.</listitem>
	    </itemizedlist>
	</sect2>
    </sect1>

    <sect1 id="ds_visdbg"><title>Visual debugging support</title>
	<sect2><title>Intro</title>
	    <simpara>
		For the debugging purpose it is required to see some "internal" data of the agent. For instance for agent-function it could be the value of its 
		arguments. Currently this feature is implemented only partially: visual representation of function has some parameter that
		defines content of which agent to display. What could be the approaches of support the full visual debugging functionality.
	    </simpara>
	</sect2>
	<sect2><title>Approach: special iface for debugging</title>
	    <simpara>This iface can include the following methods:</simpara>
	    <itemizedlist>
		<listitem>Getting value that agent gets from the given input. Use-case here is: debugging some function, there is an error within
		some internal function, user move mouse pointer to input, tooltip gets displayed showing the value.</listitem>
	    </itemizedlist>
	    <simpara>What is difference between using debugging iface and complex content for keeping debug info (ref. <xref linkend="ds_cplx_cont"/>) ?.
		Using content assumes that agent constantly updated content part that aims for debug info. This results in overhead. Of course we can
		"switch" agent to "debug mode" via dedicated content, but it seems quite complex. ARGUING: It is not nececcary that object constantly
	    refreshes debugging content. It depends on object. It can refresh the content only on demand via content getter.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_cplx_cont"><title>Complex content of agent: pros and cons</title>
	<sect2><title>Intro</title>
	    <simpara>There is proposal to add support of complex content of agent. Currently agents content is simple - just single string. 
		The complex data can be implemented as set of named data, like map[string, string] where the key is data name, and the value is the data.
		So the complex data can be considered as set of named fields.
		In many cases having complex content seems convenient and preferrable.
	       	The example is visual debugging of complex system. 
		For the debugging purpose it is required to see some "internal" data of the agent. For agent-function it could be the value of its 
		arguments. Currently this feature is implemented only partially: visual representation of function has some parameter that
		defines content of which agent to display. So to support debugging data there are two ways: 
		<orderedlist>
		    <listitem>To extend the current approach by adding some agents-paremeters (agent-function can set their content by debug data)</listitem>
		    <listitem>To add support of complex data. Agent function can set the debug data to the corresponding content fields.</listitem>
		</orderedlist>
	    </simpara>
       	</sect2>
	<sect2 id="ds_cplx_cont_cns"><title>Considerations</title>
	    <sect3><title>Simple agent philosophy</title>
		<simpara>The simple content correspond to the multy-agent philosophy "agent is simple". Complex content makes agent more comples. Does it
		    breaks the philosophy?</simpara>
	    </sect3>
	    <sect3 id="ds_cplx_cont_cns_if"><title>Agent expose its behaviour via interfaces</title>
		<simpara>So why we need content access methods in base agent interface at all? Why not have specific interfaces for access to 
		    agents content? Like it is imlpemented for property? For instance we can add the extended Prop interface, that supports named
		    property, read-only for instance or changeable. 
		    This depends on how base is this functionality, have the base agent support named properties as default? Initially the
		    idea of base agent was that it only supports native and inheritance hier.  </simpara>
		<simpara>The point here is that for changeable property also observation interface have to be defined. So the agent that
		    uses anothers agent extended Prop iface can register itself as observer. In case of embedding extd Prop iface into the base
		    agent with usage of notification to owner, this notif can create overhead.</simpara>
	    </sect3>
	    <sect3><title>Why the content update iface is required in base agent?</title>
		<simpara>It is required to support change agent via mutation. The mutation scheme is applicable to base agent only, so we
		    need some mechanism for changing agent. The subject of changing was defined as much base as possible: just some abstract content. 
		    To have complex content the agent needs to include some specific owning agents, like it is done for Edge.
		</simpara>
		<simpara>This approach differs from extended Prop iface, ref <xref linkend="ds_cplx_cont_cns_if"/> - actually there isn't 
		    mechanism to change these props via mutations. Let's have short comparition of these approaches:</simpara>
		<itemizedlist>
		    <listitem>Extended Prop iface:
			<programlisting>
			    Supports only non-persistent properties (cannot change them via mutation)
			    Supports specific observation of props, but not to owner by default
			</programlisting>
		    </listitem>
		    <listitem>Named content in base agent:
			<programlisting>
			    Supports persistent content (can be changed via mutation)
			    Supports base observation only, to owner
			</programlisting>
		    </listitem>
		</itemizedlist>
		<simpara>So it makes sense to use these approach for different aims: Complex content - to enrich the base agent, but extended prop - to
		support debugging feature.</simpara>
	    </sect3>
	    <sect3><title>Agents for just keeping data</title>
		<simpara>Currently the agent-property for just keeping data is used widely. This seems too wasteful.</simpara>
	    </sect3>
	    <sect3><title>Simple agent as subject of random mutation</title>
		<simpara>There was also idea to apply random mutation approach for system adaptation. For random approach it is important to have 
		    mutations without variable parameters. Complex content introduces mutation of type "Change content" with such variable 
		    parameter "Content name".</simpara>
		<simpara>Not sure the idea is fruitful. Even simple content agents have such kind of mutation. For instance "Change content" has
		variable parameter "Content value"</simpara>
	    </sect3>
	    <sect3><title>Content as parameters</title>
		<simpara>The content can be considered as mechanism of parametrization of agent, like it is done in OOP languages. The difference is
		    that in OOP any object can have paremeters, both primitive (like Int in Scala) and derivated. By the way, primitive object in Scala
		    has single parameter, and this paremeter is literals - "super-primitive", i.e. not object. Derivated object can be paremetrizied by
		    other objects. For our mutli-agent environment these paremeter that passed via constructor in OOP don't have sense: there is no 
		    classes in agent env, but all agent is created via inheritance. So such paremetrization in agents env can be done via mutation or 
		    view phenotypic modification. Pheno modif is more corresponding to parametrization in OOP because of OOP parametrization is the way to
		    create different instance avoiding inheritance (i.e mutation).</simpara>
		<simpara>So an agent can be parametrized via "inserting" another agents-parameters to it. The given agent has to "know" of agent-parameters 
		    capabilities in order to use them. This is the same as parameters-argument of constructor in OOP. But what if we just need primitive
		    parameter, like text data.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Comparition the apporaches in case of visual debugging</title>
	    <simpara>We will use abbreviation SC and CC for simple content and complex content correspondingly.</simpara>
	    <orderedlist>
		<listitem>Simplicity for agent-function: SD - to get the agent-prop and set its content; CC - to set the field. CC wins.</listitem>
		<listitem>For visual representation: SD - simply add new props for config of displaying; CC - same, but to interpret the props as 
		    field name. Win-win.</listitem>
		<listitem></listitem>
	    </orderedlist>
	</sect2>
    </sect1>

    <sect1 id="ds_transf"><title>Chromo transformations</title>
	<sect2 id="ds_transf_intro"><title>Introduction</title>
	    <simpara>Ref <ulink url="../requirements/index.html#uc_051"/> for use-case.</simpara>
	    <simpara>Chromo transformations are not mutations as change of model, but change of chromo itself.</simpara>
	    <simpara>Below is outline of importants points to be considered when implementing transformations:</simpara>
	    <orderedlist>
		<listitem>How to rollback transf?
		    <simpara>Some transf are just series of new mutations. In this case they can be rolled back. But the problem is that for the 
			developer they are "anonimous" and are not directly assotiated to some developers actions.</simpara>
		</listitem>
		<listitem>Transf as rich mutation
		    <simpara></simpara>
		</listitem>
	    </orderedlist>
	</sect2>
	<sect2 id="ds_transf_prntmodif"><title>Transformation to heir with applying parents pheno modifications to chromo</title>
	    <sect3><title>Introduction</title>
		<simpara>Ref <ulink url="../requirements/index.html#uc_052"/> for use-case.</simpara>
		<simpara>The practic of systems development uncover the serious problem. Let's describe the use-case. There is system A containing component
		    A_1. The system B is derivation of system A. System B also significantly modifies A_1. After that we are going to create child of A_1 assuming
		    that all modification made to A_1 will go to the child also. But this is obviously not the case because the modification are not inherited.</simpara>
		<simpara>This case shows that the following operation would be useful: to create the child with all the modification inherited.</simpara>
	    </sect3>
	    <sect3 id="ds_transf_prntmodif_repl"><title>Approach: replacing inherited component by it's child.</title>
		<simpara>One of approaches would be to replace the inherited component A_1 within B to child of A_1 - B_1. In this case all the 
		    modifications that are needed to be done in the component will be done via mutations but not modifications. This will allow the 
		    further inheritance of B_1.</simpara> 
		<simpara>But what if we already have B with component A_1 modified? How can we achieve the expected outcome? In that case we need to replace A1 with
		    (A_1:)B_1 and transforming all the modif to mutations.</simpara>
	    </sect3>
	    <sect3><title>Approach: leave inherited component but support child chromo transformation to get all parents modifto chromo.</title>
		<simpara>This approach seems more realistic.</simpara>
	    </sect3>
	    <sect3><title>Questions</title>
		<orderedlist>
		    <listitem>Could we just use "copy" of parents modifs to child? This would be naturally understanded by developer.</listitem>
		    <listitem>Why not use mutation of creating child with the option "copy modifs from parent"?
			<simpara>This would be just mutation, so no problems with its rollback. We need to take into account the 
			    inheritance mechanism where the chain of inheriting is performed beginning from root parent. To keep this mechanism we
			would need also to modify relation to parent by adding relation type ("regular inheritance", "inheritance with modifs adopted"</simpara>
		    </listitem>
		    <listitem>Why don't disable pheno modifs completely?
			<simpara>I.e. if the owner wants to change inherited comp it will need to make the comp non-inherited. This would keep the
			    whole model clear and simple. This approach is discussed in <xref linkend="ds_transf_prntmodif_repl"/>.
			    The quesion remaining - what to do if we already have such inherited comps with modifs. Anycase we need to do transformation,
			    but it will be not regular transformation but repairing. The similar repairing is already implemented for repair chromo when 
			prohibited pheno modif is disabled. Not sure this approach is correct. </simpara>
		    </listitem>
		    <listitem>How to rollback the tansformation?
			<simpara>The rollback is quite simple because the transformation is implemented via series of mutations. So
			    the initial chromo order can be stored before the transformation and then can be used for rollback.  </simpara>
		    </listitem>
		</orderedlist>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_ifnegot"><title>Agents interaction: interfaces negotiation</title>
	<sect2><title>Introduction</title>
	    <simpara>It isn't rare case that just connection establishing is not enough for agents interaction. This happens when the agent suppots 
		more that one interface to interact and it isn't suitable to specify the particular iface on connection phase. Example is function agent supporting
		variable type data. The agent is capable to handle more that one type of data. Why is such agent needed? This allows to avoid creating
		multiple similar agents, for instance agent for addition function of integer data, agent for addition function of float data etc. All these
		agents would have similar connections points set, so it seems more resonable to have agent that can supports all the types of data. </simpara>
	    <simpara>The same for data. It is excessive to have mutliple agents for keeping data of particular type. Simple is to have agent that 
		can keep data of different types. To support such approach the agent has to provide and request "flexible" interface, that specifies 
		generic methods like put data, get data, etc, but has also methods to preсise the variable parameters like data type etc.
		Such ifaces (MDVarGet, MDVarSet...) were introduced for data mutlitype agents.</simpara>
	    <simpara>Using such variable iface introduces the question of how the agents have to hegotiate to establish variable part of iface.</simpara>
	</sect2>
	<sect2><title>Negotiation of multitype function agents</title>
	    <simpara>The normal negotiation flow stars from the whole function system result point (often result data agent) and spreads to the first layer
		agents (gettng the whole function arguments), i.e. the negotiation is "from root to leafs". The negotiation procedure is as: the "upper" (nearest
		to result) agent requested the "lower" agent for required iface, the lower agent tries to handle the request, configures itself propery
		and provide the requested iface.</simpara>
	    <simpara>Breake of normal flow: the lower agent cannot provide the requested iface. This can happen when the arguments types of lower agent leads
		to result of the type that is incompatible to requested by upper agent. In this case upper agent tries other suitable variant of ifaces, if
		all they are not accepted the negitiation fails. There can be also different strategy. The simplest is that upper agent proposes other 
		ifaces keeping the contract with its upper neighbour unchanged. Another variant is that it can try also those variants that cause to the
		already established contract to upper neighbour broken. This will cause re-negotiation from lower to upper layer. </simpara>
	    <simpara>The latest approach, re-negotiation is the worther one. This is because it complicates the negotiation process.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_elem_iact"><title>Native hier: scheme of agents elementary interaction</title>
	<sect2><title>Intro</title>
	    <simpara>Agents in narive hier are related one to another according to two elemetary relation types: comp-owner for structural hier and
		parent-child for inheritance hier. This relations assume some interactions between related agents. We will call this interactions elementary
		interactions for they are induced by elementary relations. Elementary interactions are defined via interface of base object. For 
		structural hier the interface is component observer for component intercting to owner.</simpara>
	    <simpara>Actually we can consider not only single elementary relation but also relation that are induced by chan of relateions. For instance any 
		owner relates to its component, not only to direct components but also to the indirect, i.e. component of deeper layers.
		So there could be different schemes of organizing of interactions between agents related via chain of elementary relations.</simpara>
	</sect2>
	<sect2><title>Unlimited propagation</title>
	    <simpara>Currently (260ee587a) the approach is used to propagate notifications from comp to owner without any limit, to the notifications 
		achieve system root finally. This approach is simple but it causes to system getting not scalable. To have system scalable the principle of 
		isolating any relations needs to be used. Actually the tree structure itself is good example of such isolating of relations: the 
	    number of relations is reduced from bottom (comp) to uppper layers.</simpara>
	</sect2>
    </sect1>

    <sect1 id="ds_mod"><title>Support of modules</title>
	<sect2><title>Refs</title>
	    <orderedlist>
		<listitem>Use-case: <ulink url="../requirements/index.html#uc_53"/></listitem>
	    </orderedlist>
	</sect2>
	<sect2><title>Introduction</title>
	    <simpara>The current implementation of module system is rather limited: it is allowed to use ref to parent within external chromo. Also 
		it is possible to "move" node from external chromo to the model, this creates not the child of the node but the node itself, the node in
		model gets unattached. In the scope of current implementation it is not allowed to ref to external parent if this parent in turn refers to
		something.</simpara>
	    <simpara>So current approach is as: to move some modules to the model, and then refer to these modules only in scope of the model. The 
	    problem here is that there is overhead in case of big modules - not all nodes from module are used in the model.</simpara>
	</sect2>
	<sect2><title>Additional requirements.</title>
	    <sect3><title>What should be the reference?</title>
		<simpara>Currently the ref is based on url that includes uri according to RFC 3986, <xref linkend="ref_rfc_3986"/>: access protocole, authority, path, and
		    native path as uri fragment.  The native path is path in the model within native
		    coordinates. It is not convenient to use such referring approach because of necessity to specify authority and path. This makes model depending on
		environment.</simpara>
	    </sect3>
	</sect2>
	<sect2><title>Using of native uri only.</title>
	    <simpara>Using of of native uri for referring external nodes assumes that native uri allows us to unambiguously specify the node. But currently onwing hier has 
		local model as the root, so cannot be used to specify external node. Inher hier is ambiguous, so needs hint form owning heir to resolve the node.
		Nevetheless it can be used for referring - in case if system discovers some ambiguous in inher-hier it can extend ref to keep ref correct.</simpara>
	    <simpara>How it works? Assume that there are two modules and referred nodes within them:</simpara>
	    <itemizedlist>
		<listitem>Module 1: name "(Elem:)Mod_A", node "Node_R" within it </listitem>
		<listitem>Module 2: name "(Elem:)Mod_B", node "Node_R" within it </listitem>
	    </itemizedlist>
	    <simpara>In this case we can have the following unambiguous ref to Node_R in Mod_A: (Elem:)Mod_A/Node_R</simpara>
	    <simpara>What if module names are ambiguous?</simpara>
	    <itemizedlist>
		<listitem>Module 1: name "(Elem:)Mod_A", node "Node_R" within it </listitem>
		<listitem>Module 2: name "(Elem:)Mod_A", node "Node_R" within it </listitem>
	    </itemizedlist>
	    <simpara>This is possible only in case if Module 2 is delivered by some authority independent from that delivers Module 1. So how to extend ref uri?
		One way is to extend with base rfc url authority/path, having specific authority/path for Module 2 authority.</simpara>
	    <simpara>In fact the authority/path is nothing but one more coordinate in the system space. We can achieve the similar result with explicitly
		adding new specific coordinate, for instance "authority", to strengthen ref safety. To have one more coordinate we need to introduce new type of 
		relations, that generates the coordinate. Of course specific node is required by authority. 
		Looking at this we can propose simpler approach: system can just extend owning-hier by authority node in case if system
		discover ref unambiguousness.</simpara>
	    <itemizedlist>
		<listitem>Module 1: name "(Elem:)Mod_A", node "Node_R" within it </listitem>
		<listitem>Module 2: name "(Elem:)Mod_A", node "Node_R" within it </listitem>
		<listitem>System create module with unambiguous "Module_2_Authority" node and "includes" Module 2 Mod_A into it. So now we refer to Module 2
		    Node_R as: Elem:(Module_2_Authority/Mod_A/)Node_R </listitem>
	    </itemizedlist>
	    <simpara>Looks good, so now we have heir-hier as one "absolute" coordinate, but resolving unambiguousness with onwining-hier. System searches modules
		on local file or specified url according to some rules. But we still haven't avoided explicit stating rfc url, because actually system includes
		Module 2 Mod_A into Module_2_Authority by authority/path. Howewer for our model, we can use only native url.</simpara>
	</sect2>
	<sect2><title>How to include nodes from modules in the model</title>
	    <sect3><title>Intro</title>
		<simpara>First of all system has to provide the hierarchy of the nodes in modules in order to allow user to select the node required.</simpara>
		<simpara>Then system has to differentiate refs to the models nodes (real nodes) from refs to modules nodes (actually not real nodes but nodes chromo).</simpara>
	    </sect3>
	    <sect3><title>Considerations</title>
		<orderedlist>
		    <listitem>
			The main idea for the modules is to support full referencing for modules, i.e. 
			that standard references from models chromo to any “nodes” in modules are to be allowed, as if it is run-time node. 
			The rationale of such ajn approach is that it should be simple for implementation because of modules compacted 
			chromo native space (inducted by coordinates of native hierarchies) is the same as for runtime generated from modules chromo.  </listitem>
		    <listitem>
			To implement this approach we need to re-implement chromo in order to support inheritance hier also.  
			There is a problem here: actually the chromo itself is not isomorphic to run-time, for instance mutation of adding 
			not to destination has different owner as generated model.  Solution here would be implementing of “enhanced” chromo, 
			where mutations “branching” nodes (i.e. [node]) keeps also run-time relations owner-component.  </listitem>
		    <listitem>
			Or we could create “intermediate” run-time model, where only structure is evolved but not all mutations applied. 
			But any case is will not the same as currently implemented. Current implementation allows user to reference to any node 
			within module, even the inherited node. Nor chromo neither intermediate model don’t allow to do that. 
			Is this real limitation? Perhaps not. We can apply the restrictions for referencing nodes from modules: 
			to use only direct and attached nodes (direct means that adding node destination is mutation owner. 
			In this case we just need simple extended chromo with support of inher hier.  </listitem>
		    <listitem>
			There is fundamental problem in referring to modules. In fact the current referring scheme is dedicated for run-time, 
			so any reference is reference to an agent. So even now, referring to the whole module is ambiguous because it’s 
			the reference to chromo. The differentiation between ref to agent and ref to chromo is performed implicitly, look at 
			Elem::AddElem(): uri scheme is used to decide what ref is. Some kind of logic presents here: if we ref inside the model 
			then scheme (or base part of uri) isn’t needed (internal ref), if we referring to external something then it is cpec (chromo) </listitem>
		    <listitem>
			Note that referring to chromo is required only for referring to parent or to moving source. So maybe it makes sense 
			to keep the current implementation with small improvement: A). introduce specific scheme or base part for modules nodes, 
			for instance fap://modules#....  B). environment to provide the modules tree </listitem>
		    <listitem>
			Problem: creating from external parent is ambiguous. This is because creating two agent from one parent in the same owner 
			will cause an error: second creation parent will filed because of already having such agent in the owner.  
			Solution here would be to disable external parent, so only moving will be allowed for externals.  </listitem>
		    <listitem>
			In some module it is possible that internal node has ref to another node in this module, for instance Molule/B can have ref to local 
			parent Module/A. In this case moving “B” will cause an error. Solution: consider such nodes as dependent and disable moving them.  </listitem>
		    <listitem>
			One more problem : currently the cyclic resolution of module refs are not supported.
			This means that if model uses module_1 and within module_2 there are refs to module_2 so just moving module_1 to the model will 
			cause the error of refs not resolved. Solution here could be to move dependency to the module. The disadvantage here is that the 
			deps can be duplicated in many modules. Another solution would be “importing” deps. 
			Importing means that we have specific node for modules in owning hier and move specified dep to this node in case 
			if it’s not there yet. Such dedicated node is “/Modules” in the current implementation. OR system can do it automatically, 
			enumerating all deps, checking if dep is already “imported” and import if not. This is actually caching the modules: 
			system uses the proper run-time url in the “cache” (/Modules) and moves the external in case the cache is missing for it. 
			Even more: we can create dedicated agent for modules. This agent behavior is to cache externals, i.e to create the proper 
			nodes with externals chromo. Module agent can also provide the tree of module, whereas getting chromo itself needs to 
			be implemented on env level because is platform dependent.  </listitem>
		    <listitem> What if base agent includes specific modules agent for keeping agent related modules?  </listitem>
		</orderedlist>
	    </sect3>
	</sect2>
	<sect2 id="ds_mod_agt"><title>Module agent</title>
	    <sect3 id="ds_mod_agt_uc"><title>Use-cases</title>
		<sect4><title>Getting tree of chromo nodes</title>
		</sect4>
		<sect4><title>Moving component of module</title>
		    <simple>This is creating component via applying given chromo node from the module. Agent creates all owning hier but not fulfilles
		    owners of created comp.</simple>
		</sect4>
	    </sect3>
	    <sect3><title>APIs</title>
		<itemizedlist>
		    <listitem>Get tree of chromo nodes</listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
    </sect1>

    <sect1 id="ds_prb"><title>Problems</title>
    </sect1>

    <sect1 id="ds_tohandle"><title>To handle</title>
	<orderedlist>
	    <listitem>Using mut order to ensure original sequence of muts, ref <xref linkend="ds_mut_dis_pheno"/> </listitem>
	    <listitem>References: rules and limitations, ref <xref linkend="ds_mut_refs"/> </listitem>
	</orderedlist>

    </sect1>

</article>
