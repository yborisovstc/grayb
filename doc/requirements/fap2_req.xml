<?xml version="1.0" ?>

<!DOCTYPE article SYSTEM "/usr/share/sgml/docbook/dtd/xml/4.5/docbookx.dtd">


<article status="draft" class="specification"> <title>Enhanced Discrete Events System framework (graph based). Requirements.</title>

    <articleinfo>
	<author><personname><firstname>Yuri</firstname><surname>Borisov</surname></personname>
	    <email>yuri.borisov.v@gmail.com</email></author> 

	<releaseinfo>Ver.0.01 at 30-Nov-2011</releaseinfo>

	<abstract>
	    <simpara>This document collects use-cases and software requirements for Discrete Events System framework ver 2.</simpara>
	</abstract>

	<revhistory>
	    <revision> <revnumber>0.01</revnumber> <date>30-Nov-2011</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Initial version</revremark> </revision>
	    <revision> <revnumber>0.02</revnumber> <date>19-Mar-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="uc_03"/></revremark> </revision>
	    <revision> <revnumber>0.03</revnumber> <date>28-Mar-2013</date> <authorinitials>Yuri Borisov</authorinitials>
		<revremark>Added <xref linkend="uc_grahp_04"/></revremark> </revision>
	</revhistory>

    </articleinfo>

    <bibliolist>
	<title>References</title>
    </bibliolist>

    <sect1 id="nimp"><title>Treaceability: not implemented yet</title>
	<itemizedlist>
	    <listitem> <xref linkend="uc_014"/> </listitem>
	</itemizedlist>
    </sect1>

    
    <sect1 id="uc"> <title>Use cases</title>
	<sect2 id="uc_000"><title>UC_000 Usecase template</title>
	    <sect3><title>Actors</title>
		CLIENT: some element of system - also named "interface requestor".
	    </sect3>
	    <sect3><title>Preconditions</title>
	    </sect3>
	    <sect3><title>Assumptions</title>
	    </sect3>
	    <sect3><title>Normal</title>
		<simpara>Normal flow</simpara>
	    </sect3>
	    <sect3><title>Alternative</title>
		<simpara>Alternative flows</simpara>
	    </sect3>
	    <sect3><title>Exceptions</title>
	    </sect3>
	    <sect3><title>Variations</title>
	    </sect3>
	    <sect3><title>Extends</title>
	    </sect3>
	    <sect3><title>Extended by</title>
	    </sect3>
	    <sect3><title>Discussion</title>
	    </sect3>
	    <sect3><title>Clarification</title>
	    </sect3>
	</sect2>
	<sect2 id="uc_01"><title>UC_01 Logging</title>
	    <sect3><title>Description</title>
		CLIENT requests logging and specifies logging parameters - SYSTEM provides CLIENT with logging data
	    </sect3>
	    <sect3><title>Extension of</title>
	    </sect3>
	    <sect3><title>Extended by</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_020"/></listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="uc_020"><title>UC_020 Logging configuration of element</title>
	    <sect3><title>Description</title>
		CLIENT selects some particular element and requests logging configuration - SYSTEM provides CLIENT with means of 
		logging configuration.
	    </sect3>
	    <sect3><title>Extension of</title>
		<simpara><xref linkend="uc_01"/></simpara>
	    </sect3>
	    <sect3><title>Extended by</title>
	    </sect3>
	</sect2>

	<sect2 id="uc_021"><title>UC_021 Getting parent nodes available.</title>
	    <sect3><title>Description</title>
		CLIENT requests adding new graph node into the graph - SYSTEM offers the following ways to do this:
		<itemizedlist>
		    <listitem>From the current graphs loaded in environment by specifyinc local URI </listitem>
		    <listitem>From external graph by specifying full URI (URI includes graph spec and node within the spec)</listitem>
		    <listitem>From graph provider</listitem>
		</itemizedlist>
	    </sect3>
	</sect2>

	<sect2 id="uc_002"><title>UC_002 Creation from spec</title>
	    <sect3><title>Description</title>
		CLIENT requests creation of graph by spec - SYSTEM creates the graph using the spec given.
	    </sect3>
	    <sect3><title>Extentions</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_017"/></listitem>
		    <listitem><xref linkend="uc_016"/></listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Discussion</title>
		<orderedlist>
		    <listitem>Actually the spec is the sequence of the changes (mutations) of system. </listitem>
		</orderedlist>
	    </sect3>
	</sect2>

	<sect2 id="uc_017"><title>UC_017 Spec of creation </title>
	    <sect3><title>Description</title>
		[Ext UC_GRAPH_02] Graph spec consists of:
		<itemizedlist>
		    <listitem>Name</listitem>
		    <listitem>Parent</listitem>
		    <listitem>Mutations</listitem>
		</itemizedlist>
		<simpara>The mutation can be as:</simpara>
		<itemizedlist>
		    <listitem>Adding node</listitem>
		    <listitem>Changing of node attributes</listitem>
		</itemizedlist>
		<simpara>The spec can be consider as "chromosome" of a graph. The spec can </simpara>
	    </sect3>
	    <sect3><title>Extentions</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_018"/></listitem>
		</itemizedlist>
	    </sect3>
	</sect2>

	<sect2 id="uc_graph_03"><title>UC_GRAPH_03 Serialization as spec</title>
	    <sect3><title>Description</title>
		CLIENT requests serialization - SYSTEM serialize the graph as graph spec.
	    </sect3>
	    <sect3><title>Extentions</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_017"/></listitem>
		</itemizedlist>
	    </sect3>
	</sect2>

	<sect2 id="uc_grahp_04"><title>UC_GRAHP_04 Providing ifaces</title>
	    <sect3><title>Description</title>
		CLIENT requests element for some interface - SYSTEM ensures elements providing interface or indicates that the interface 
		cannot be provided.
	    </sect3>
	    <sect3><title>Details</title>
		<itemizedlist>
		    <listitem>The corporative approach is to be used, so element can provide not only "it's owned" interface but 
			also interface provided by elements that "cooperate" to it.</listitem>
		    <listitem>The policy of providing interface in cooperative network is to be defined</listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="uc_03"><title>UC_03 Connection</title>
	    <sect3><title>Description</title>
		CLIENT requests connecting two systems - SYSTEM allows connecting systems so one system gets able to communicate to another.
	    </sect3>
	    <sect3><title>Details</title>
		<itemizedlist>
		    <listitem>System contains end points for connection. Connection is established via creating relation between
			end points of two systems. Such connection endpoints are called Connection points (CP).</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extension of</title>
	    </sect3>
	    <sect3><title>Extended by</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_06"/></listitem>
		    <listitem><xref linkend="uc_012"/></listitem>
		    <listitem><xref linkend="uc_015"/></listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="uc_06"><title>UC_06 Extention</title>
	    <sect3><title>Description</title>
		CLIENT requests to exhibit iface of  some internal component of the system - SYSTEM provides this via having CP that on 
		one hand serves as end point for connection from external system but on the oner hand is connected to internal component.
		Such connection point is called Extention Point (EP).
	    </sect3>
	    <sect3><title>Details</title>
		<itemizedlist>
		    <listitem>. </listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extension of</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_03"/></listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="uc_007"><title>UC_007 CPs providing interfaces</title>
	    <sect3><title>Description</title>
		CLIENT requests CP for some interface - CP provides only interface that is specified as provided.
	    </sect3>
	    <sect3><title>Details</title>
		<itemizedlist>
		    <listitem>There is no possibility for CLIENT to obtains some other interface of system via the CP. </listitem>
		    <listitem>Is this constraint really needed? In fact the connecting policies avoid connecing incompatible CP.
			The only problem can be access through C interface.</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extension of</title>
	    </sect3>
	    <sect3><title>Extended by</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_008"/></listitem>
		    <listitem><xref linkend="uc_009"/></listitem>
		    <listitem><xref linkend="uc_010"/></listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="uc_008"><title>UC_008 CPs providing multiple instances of interfaces</title>
	    <sect3><title>Description</title>
		CLIENT requests CP for instances of some interface - CP provides available instances of specified  interface.
	    </sect3>
	    <sect3><title>Details</title>
		<itemizedlist>
		    <listitem>One important case is when some system internal component requests ifaces from system connection point. 
			Multiple connection to that point are allowed. So the requiest shall result in returning the set of iface 
			implementations.
		    </listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extension of</title>
		<xref linkend="uc_007"/>
	    </sect3>
	    <sect3><title>Extended by</title>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="uc_009"><title>UC_009 Caching of Interfaces</title>
	    <sect3><title>Description</title>
		CLIENT: some element of system.
		CLIENT requests some element for interface - SYSTEM (requested element) returns the interface (or instances of 
		interface) and also caches the ifaces. CLIENT requests SYSTEM for the same interface - SYSTEM returns the
		cached instances of interface.
	    </sect3>
	    <sect3><title>Details</title>
		<itemizedlist>
		    <listitem> </listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extension of</title>
		<xref linkend="uc_007"/>
	    </sect3>
	    <sect3><title>Extended by</title>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="uc_010"><title>UC_010 Interface requestor being notified of interface added</title>
	    <sect3><title>Description</title>
		CLIENT: some element of system - also named "interface requestor".
		CLIENT requests SYSTEM for interface - SYSTEM returns the interface (or instances of 
		interface). Some new interface that meets the request has been added - SYSTEM notifies CLIENT of that, so
		CLIENT can request refreshing interfaces in cache.
	    </sect3>
	    <sect3><title>Details</title>
		<itemizedlist>
		    <listitem> </listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extension of</title>
		<xref linkend="uc_007"/>
	    </sect3>
	    <sect3><title>Extended by</title>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="uc_005"><title>UC_005 Sockets</title>
	    <sect3><title>Description</title>
		CLIENT requests connection of endpoints that are more complex that single CP - SYSTEM provides the means of connecting in 
		form of socket.
	    </sect3>
	    <sect3><title>Details</title>
		<itemizedlist>
		    <listitem>Socket is element that contains other CPs, or sockets. So socket can be quite complex
		    hierarhy of elements.</listitem>
		    <listitem>Sockets are to be compatible in order to be connected.</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extension of</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_03"/></listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extended by</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_011"/></listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="uc_011"><title>UC_011 Extention of sockets</title>
	    <sect3><title>Description</title>
		CLIENT requests extending of some internal socket - SYSTEM extends the socket via proper extention point
		form of socket.
	    </sect3>
	    <sect3><title>Details</title>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="uc_012"><title>UC_012 CPs with no ifaces directly specified</title>
	    <sect3><title>Description</title>
		CLIENT: some element of system - also named "interface requestor".
		CLIENT requests SYSTEM for create some system that can provide several ifaces via one CP (so that CP can be used
		to connect to systems required different ifaces)
		- SYSTEM allows to create such system without specifying the particular provided iface (or spedifying the list of ifaces 
		provided)
	    </sect3>
	    <sect3><title>Details</title>
		<itemizedlist>
		    <listitem>This usecase allows to have dynamically configured system. One example is function "Add" that
			can handle different type of data - int, float, complex etc. It is possible to embed agent that suppports 
			all required ifaces, but we also need to CP allows such flexibility. </listitem>
		    <listitem>In this case CP can verify compatibility also "dynamically" using not prop with iface specified but
			asking system if the iface is supported</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extension of</title>
		<xref linkend="uc_03"/>
	    </sect3>
	    <sect3><title>Extended by</title>
		<itemizedlist>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="uc_013"><title>UC_013 Mutation</title>
	    <sect3><title>Actors</title>
		CLIENT: user of FAP model
	    </sect3>
	    <sect3><title>Precondition</title>
	    </sect3>
	    <sect3><title>Normal</title>
		CLIENT prepares specification of change in MODEL and requests MODEL for changing - MODEL performs the mutation and responce CLIENT of 
		mutation result
	    </sect3>
	    <sect3><title>Extended by</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_014"/></listitem>
		</itemizedlist>
	    </sect3>
	</sect2>
	<sect2 id="uc_014"><title>UC_014 Trying of mutation</title>
	    <sect3><title>Actors</title>
		CLIENT: user of FAP model
	    </sect3>
	    <sect3><title>Precondition</title>
	    </sect3>
	    <sect3><title>Normal</title>
		CLIENT has some options of changing MODEL, CLIENT want to check if these options are valid for MODEL - MODEL provides
		means of checking the validity of changes.
	    </sect3>
	    <sect3><title>Alternative</title>
	    </sect3>
	    <sect3><title>Exceptions</title>
	    </sect3>
	    <sect3><title>Extends</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_013"/></listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extended by</title>
	    </sect3>
	    <sect3><title>Discussion</title>
		<itemizedlist>
		    <listitem>Example of this UC is studio application that uses model and allows user to create and change it. User for instance
			can create system with childs inside plus edge. Then user can try to connect the edge to some elements. So user pull the connection 
			point of the edge thru the list of the elements whereas the application shows to the user if the element is sutable for connection. 
			So the container element should give to application some mechanism to try connection and verify if it would be ok.</listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Clarification</title>
	    </sect3>
	</sect2>

	<sect2 id="uc_015"><title>UC_015 Edges correcting when removing vert</title>
	    <sect3><title>Actors</title>
		VERT: some vertex witin upper node.
		EDGE: edge 
		UPPER_NODE: node that contains VERT and EDGE
	    </sect3>
	    <sect3><title>Preconditions</title>
		EDGE is connected to VERT
	    </sect3>
	    <sect3><title>Normal</title>
		<simpara>Mutation of UPPER_NODE is done that removes VERT, UPPER_NODE disconnects EDGE from VERT so that connection point previously 
		connected to VERT gets free.</simpara>
	    </sect3>
	    <sect3><title>Extends</title>
		<xref linkend="uc_015"/>
	    </sect3>
	    <sect3><title>Extended by</title>
	    </sect3>
	</sect2>

	<sect2 id="uc_016"><title>UC_016 Node containing spec keeping all mutations</title>
	    <sect3><title>Actors</title>
		CLIENT: some subject using system.
		NODE: some node of system
	    </sect3>
	    <sect3><title>Normal</title>
		<simpara>CLIENT requests NODE for some series of mutations. NODE performs mutation and stores the mutation series in nodes spec. </simpara>
	    </sect3>
	    <sect3><title>Extends</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_002"/></listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extended by</title>
	    </sect3>
	    <sect3><title>Discussion</title>
		<orderedlist>
		    <listitem>The current implementation (332ab196bc0988f1e471ebfa708f44310b5f9f94) doesn't conform to this usecase. This is because the node deletion 
		   mutation isn't kept in spec. Instead of this the runtime node removes and also removes its spec, so the parent spec gets missing this child spec. </listitem>
		</orderedlist>
	    </sect3>
	</sect2>

	<sect2 id="uc_018"><title>UC_018 Adding node</title>
	    <sect3><title>Actors</title>
		CLIENT: some subject using system.
		NODE: some node of system
	    </sect3>
	    <sect3><title>Normal</title>
		<simpara>CLIENT requests NODE for mutation by adding the node basing on given parent - NODE performs the mutation </simpara>
	    </sect3>
	    <sect3><title>Extends</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_017"/></listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extended by</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_019"/></listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Discussion</title>
		<orderedlist>
		</orderedlist>
	    </sect3>
	</sect2>

	<sect2 id="uc_019"><title>UC_019 Nodes spec not containing parents spec</title>
	    <sect3><title>Actors</title>
		CLIENT: some subject using system.
		PARENT: some parent node within the system
		NODE: some node of system
		CHILD: node created basing on PARENT
	    </sect3>
	    <sect3><title>Normal</title>
		<simpara>CLIENT requests NODE for mutation by adding the node basing on PARENT - NODE performs the mutation so creates new CHILD basing on PARENT, 
		    NODE doens't include PARENTs spec into CHILDs spec.</simpara>
	    </sect3>
	    <sect3><title>Extends</title>
		<itemizedlist>
		    <listitem><xref linkend="uc_018"/></listitem>
		</itemizedlist>
	    </sect3>
	    <sect3><title>Extended by</title>
	    </sect3>
	    <sect3><title>Discussion</title>
		<orderedlist>
		    <listitem>This has serious consequences when building DES. For instance the case discovered when using DES Studio app: parent has some internal node named "Int_Node", 
			then we create CHILD basing on that parent. From Studio we can the whole run-time structure of child, so we can see that child contains node named "Int_Node".
			Then we open this "Int_Node" and try to mutate it somehow. As result we can see the mutation in Studio (i.e in DES run-time structure) but when we check
			the spec we cannot see the mutation we did. This is because the "Int_Node" spec is not included ("attached") to CHILDs spec thus isn't stored.</listitem>
		    <listitem>This specific means that we need to keep all parents "alive". If some parent is deleted that it will be not possible 
			to inherit even from the parent's child.</listitem>
		</orderedlist>
	    </sect3>
	</sect2>

    </sect1>

</article>
